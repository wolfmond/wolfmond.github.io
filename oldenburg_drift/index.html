<!doctype html>
<!-- 

All rights reserved. At least at this very moment; I'm planning to realease this game into the Creative Commons, but please let me finish it first. It's still super buggy and I have a lot of Ideas. It's playable, yet; but don't expect too much. This is merely a draft, yet. Greetz, Wolfmond

Current Version: 2025-09-23_4.13

-->
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Oldenburg Kart ‚Äî Optimized + Music Menu</title>
<script>
const message = "‚ö†Ô∏è This is a highly experimental Prototype. Not yet intended for public use. All Rights Reserved. No Warranties. Use this software at your own risk. This website can be played with arrow keys on your keyboard on a Laptop/PC. Tested with Chrome & Brave. In my Tests: Runs best in Chrome Browser. Language (yet): GERMAN";

// Zeigt eine Best√§tigungsbox an
if (!confirm(message)) {
  // Wenn der Nutzer auf "Abbrechen" klickt
  window.location.href = "about:blank";
}
</script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  :root{
	--bg:#222222;
	--panel:#fff;
	--muted:#666;

 --car-top:    #7a00ff;    /* violet */
  --car-bottom: #160032;    /* deep indigo */
  --car-accent: #ff9ee7;    /* neon pink for triangle */
  --car-rim:    rgba(255,255,255,0.12);
  --car-glow:   rgba(122,0,255,0.18);
  
  
  }
  html,body,#map { height:100%; margin:0; padding:0; font-family: system-ui, Arial, sans-serif; cursor:none; }
  #map { position:relative; overflow:hidden; background:#e7eef8; }

  /* --- Car UI --- */
  /* circle / body */
.car-center{
  position: absolute;
  z-index: 12000;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 40px;
  height: 40px;
  border-radius: 50%;
background: radial-gradient(circle at center, var(--car-top), var(--car-bottom));

  border: 2px solid var(--car-rim);
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  /* multi-layered glow + inner subtle sheen */
  box-shadow:box-shadow:
  0 0 18px rgba(0,0,0,0.6),
  0 0 26px var(--car-glow),
  0 0 6px rgba(255,158,231,0.06) inset;
  transition: transform 160ms ease, box-shadow 160ms ease, background 220ms ease;
}

/* slight bounce look */
.car-center.bounce{
  transform: translate(-50%,-48%) scale(1.02);
  box-shadow:
    0 6px 14px rgba(0,0,0,0.65),
    0 10px 30px var(--car-glow);
}

/* make SVG polygon crisp and enable color transitions */
.car-center svg { width: 22px; height: 22px; display:block; }
.car-center polygon {
  transition: fill 180ms ease, stroke 180ms ease, transform 160ms ease;
  filter: drop-shadow(0 4px 10px rgba(122,0,255,0.18));
}

  .score { position:absolute; top:12px; right:12px; z-index:14000; background: rgba(255,255,255,0.95); padding:8px 12px; border-radius:8px; font-weight:700; display:flex; gap:12px; align-items:center; box-shadow: 0 6px 18px rgba(0,0,0,0.08); }
  .loader { position:absolute; top:12px; left:12px; z-index:14000; background: rgba(255,255,255,0.96); padding:10px; border-radius:8px; font-size:13px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); min-width:220px; }
  .finish-overlay { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:16000; background: rgba(255,255,255,0.96); padding:18px 22px; border-radius:12px; box-shadow: 0 10px 30px rgba(0,0,0,0.12); display:none; font-weight:800; }

  /* --- Music menu (z-index high) --- */
  .menu-panel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%) scale(0.98);width:min(860px,95vw);background:var(--panel);box-shadow:0 20px 60px rgba(0,0,0,0.12);border-radius:12px;padding:18px;opacity:0;pointer-events:none;transition:opacity .22s ease, transform .22s ease;z-index:20050; cursor:pointer;}
  .menu-panel.open{opacity:1;transform:translate(-50%,-50%) scale(1);pointer-events:auto}
  .menu-inner{display:flex;flex-direction:column;gap:12px}
  .iframe-wrap{position:relative;border-radius:10px;overflow:hidden;border:1px solid rgba(0,0,0,0.06)}
  #mixcloudPlayer{width:100%;height:160px;border:0;display:block}
  /* overlay text sits visually over iframe but does not block clicks */
  .iframe-overlay{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(255,255,255,0.0),rgba(255,255,255,0.0));pointer-events:none}
  .overlay-text{background:rgba(255,255,255,0.02);padding:10px 14px;border-radius:8px;font-weight:600;color:#333}
  .mini-status{font-size:0.9rem;color:var(--muted);text-align:center;margin-top:6px}

  @media (max-width:480px){ #mixcloudPlayer{height:120px} .menu-panel{padding:12px} }
  
  .controls-help { font-size:0.92rem; color:var(--muted); margin-top:10px; text-align:center; display:flex; flex-direction:column; gap:6px; }
.help-title { font-weight:700; color:#222; margin-bottom:2px; }
.help-list { display:flex; flex-direction:column; gap:6px; align-items:center; }
.controls-help kbd {
  display:inline-block; padding:4px 7px; border-radius:6px; background:#fafafa;
  border:1px solid rgba(0,0,0,0.06); box-shadow: inset 0 -1px 0 rgba(0,0,0,0.03);
  font-weight:700; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
}
@media (max-width:480px){ .controls-help { font-size:0.85rem; } .controls-help kbd{ padding:3px 6px } }

.menu-action{
  background: #fff;
  border: 1px solid rgba(0,0,0,0.06);
  padding: 8px 12px;
  border-radius: 10px;
  font-weight:700;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  cursor: pointer;
}
.menu-action[aria-pressed="true"]{
  background: #222;
  color:#fff;
  border-color: rgba(0,0,0,0.12);
}

@media (max-width:480px){ .menu-action{ padding:6px 10px } }

#fullscreenBtn {
	border: 1px solid black;	
}

  
  .leaflet-tile { filter: hue-rotate(var(--map-hue, 0deg)) saturate(0.3) contrast(1.03) brightness(1.02) invert(1); }
  
  
</style>
</head>
<body>
  <div id="map"></div>

<!--  <div class="car-center" id="carDiv" title="Dein Wagen"><div class="car-arrow" id="carArrow"></div></div>-->

<div class="car-center" id="carDiv" title="Dein Wagen">
  <!-- SVG triangle: fill = accent, stroke = soft outline -->
  <svg width="22" height="22" viewBox="0 0 100 100" aria-hidden="true" focusable="false">
    <polygon id="carTriangle" points="50,8 86,86 14,86"
      fill="var(--car-accent,#ff9ee7)"
      stroke="rgba(255,255,255,0.14)"
      stroke-width="3"
      stroke-linejoin="round"/>
  </svg>
</div>

<!-- Missions-UI: Pfeil + Meter (unten rechts) -->
<div id="missionUI" aria-live="polite" style="position:fixed; right:12px; bottom:12px; z-index:16050; font-family:system-ui,Arial,sans-serif;">
  <div id="missionBox" style="backdrop-filter:blur(6px); background: rgba(255,255,255,0.95); border-radius:10px; padding:10px 12px; box-shadow:0 8px 24px rgba(0,0,0,0.12); min-width:160px; display:flex; gap:10px; align-items:center;">
    <div id="missionArrow" style="width:42px; height:42px; display:flex; align-items:center; justify-content:center; transform: rotate(0deg); transform-origin:center; transition: transform 160ms linear;">

      <!-- Simple SVG arrow -->
      <svg viewBox="0 0 100 100" width="34" height="34" aria-hidden="true">
        <g transform="translate(50,50)">
          <path id="arrowPath" d="M0,-36 L14,18 L0,6 L-14,18 Z" fill="#7a00ff" stroke="rgba(0,0,0,0.06)" stroke-width="2"></path>
        </g>
      </svg>
    </div>
    <div style="display:flex;flex-direction:column;">
      <div id="missionTitle" style="font-weight:800; font-size:14px; color:#111">‚Äî Lade Mission ‚Äî</div>
      <div id="missionDistance" style="font-size:13px; color:#444">‚Äî m ‚Äî</div>
    </div>
  </div>
</div>

  <div class="loader" id="loader">
    <div style="font-weight:700">Oldenburg Kart ‚Äî Optimized</div>
    <div class="small">Lade ein GeoJSON (FeatureCollection mit LineString). Standard Sterne-Abstand: <strong>100 m</strong>.</div>
    <input id="geoFile" type="file" accept="application/json,application/geo+json" />
    <div style="margin-top:8px" class="row"><button id="centerBtn" style="min-width:80px">Zentrieren</button> <button id="resetBtn" style="min-width:80px">Reset</button></div>
  </div>

  <div class="score"><div>Score: <span id="score">0</span></div><div id="hs">Highscore: 0</div></div>
  <div class="finish-overlay" id="finishOverlay">Strecke beendet üéâ</div>

  <!-- Musik-Menu (Space toggled) -->
  <div class="menu-panel" id="menuPanel" aria-hidden="true">
    <div class="menu-inner">
      <div class="iframe-wrap">
        <!-- Passe das feed URL nach Bedarf an -->
        <iframe id="mixcloudPlayer" src="https://www.mixcloud.com/widget/iframe/?feed=https://www.mixcloud.com/DarknessForever/neonvisions1-07ef66c492e097d6b34282657dbfa5bd/&hide_cover=1&hide_tracklist=1&mini=1" allow="encrypted-media"></iframe>
        <div class="iframe-overlay" id="iframeOverlay"><div class="overlay-text" id="overlayText">Einmal in den Player klicken und Play dr√ºcken</div></div>
      </div>
      <!--<div class="mini-status" id="miniStatus">Warte auf Interaktion‚Ä¶</div>-->
	  
	  <!-- Vollbild-Button: direkt unter den Hilfetext einf√ºgen -->
<!-- neben dem Vollbild-Button -->
<div style="display:flex;justify-content:center;margin-top:8px;gap:8px">
  <button id="fullscreenBtn" class="menu-action" type="button" aria-pressed="false">Vollbild</button>
  <!-- neuer SFX Toggle -->
  <button id="sfxBtn" class="menu-action" type="button" aria-pressed="true">SFX: An</button>
  <!-- neuer Music Toggle (optional sichtbarer Button) -->
  <!--<button id="musicBtn" class="menu-action" type="button" aria-pressed="true">Musik: An</button>-->
</div>


	  <div class="controls-help" id="controlsHelp" aria-live="polite">
  <div class="help-title">Tastenbelegung</div>
  <div class="help-list">
    <div><kbd>1‚Äì9</kbd> Speed √§ndern ‚Äî aktueller Gang: <strong id="controlsHelpGear">1</strong></div>
    <div><kbd>F</kbd> Vollbild an/aus</div>
    <div><kbd>M</kbd> Musik an/aus</div>
    <div><kbd>Leertaste</kbd> Men√º √∂ffnen / schlie√üen</div>
  </div>
</div>



    </div>
  </div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/zzfx@1.3.2/ZzFXMicro.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

<!-- Mixcloud widget API (f√ºr PlayerWidget) -->
<script src="https://widget.mixcloud.com/media/js/widgetApi.js"></script>

<script>
/* ============================
   Integrierte Spiel-Logik (wie vorher, optimiert)
   ============================ */

/* ---------- CONFIG ---------- */
const MAP_ZOOM = 19;
const MAP_HUE_ROTATION = 90;
const STAR_SPACING = 100; // wichtig: nicht 10!
const MAX_STARS = 800;
const PICKUP_PIXEL_DIST = 14;
const FINISH_DISTANCE_METERS = 8;
//const SPEED_GEARS = {1:{speed:15,accel:10},2:{speed:25,accel:15},3:{speed:35,accel:20},4:{speed:45,accel:25},5:{speed:60,accel:30}};
const SPEED_GEARS = {
  1: { speed: 15,  accel: 10 },
  2: { speed: 25,  accel: 15 },
  3: { speed: 35,  accel: 20 },
  4: { speed: 45,  accel: 25 },
  5: { speed: 60,  accel: 30 },
  6: { speed: 75,  accel: 35 },
  7: { speed: 95,  accel: 45 },
  8: { speed: 120, accel: 60 },
  9: { speed: 150, accel: 80 }
};
let currentGear = 3; 
currentGear = Math.min(9, Math.max(1, Number(currentGear) || 1));

let MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed; let ACCEL = SPEED_GEARS[currentGear].accel;
const STARTPOS = [53.143559, 8.22416];

/* ---------- MAP ---------- */
const map = L.map('map', { keyboard:false, zoomControl:false, minZoom:MAP_ZOOM, maxZoom:MAP_ZOOM, scrollWheelZoom:false, doubleClickZoom:false, touchZoom:false, dragging:false, boxZoom:false }).setView(STARTPOS, MAP_ZOOM);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { minZoom:MAP_ZOOM, maxZoom:MAP_ZOOM, keepBuffer:2, attribution: '<a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noreferrer">¬© OpenStreetMap contributors</a>' }).addTo(map);
document.documentElement.style.setProperty('--map-hue', MAP_HUE_ROTATION + 'deg');
const canvasRenderer = L.canvas({ padding: 0.5 });

/* ---------- DOM ---------- */
const mapDiv = document.getElementById('map');
const carDiv = document.getElementById('carDiv');
const loaderEl = document.getElementById('loader');
const geoFileEl = document.getElementById('geoFile');
const centerBtn = document.getElementById('centerBtn');
const resetBtn = document.getElementById('resetBtn');
const scoreEl = document.getElementById('score');
const hsEl = document.getElementById('hs');
const finishOverlay = document.getElementById('finishOverlay');
const missionBox = document.getElementById('missionBox');


/* ---------- STATE ---------- */
let roads = [], stars = [], roadPixelSegments = [], score = 0, finished = false;
hsEl.textContent = 'Highscore: ' + (localStorage.getItem('oldenburg_kart_highscore_custom')||0);
function updateScore(){ scoreEl.textContent = score; const prev = Number(localStorage.getItem('oldenburg_kart_highscore_custom')||0); if(score>prev){ localStorage.setItem('oldenburg_kart_highscore_custom', score); hsEl.textContent = 'Highscore: ' + score; } }

/* ---------- HELPERS ---------- */
const R = 6378137; function toRad(d){return d*Math.PI/180;} function toDeg(r){return r*180/Math.PI;}
function destinationPoint(lat, lon, distanceMeters, bearingDeg){ const Œ¥ = distanceMeters / R; const Œ∏ = toRad(bearingDeg); const œÜ1 = toRad(lat); const Œª1 = toRad(lon); const sinœÜ1=Math.sin(œÜ1), cosœÜ1=Math.cos(œÜ1); const sinŒ¥=Math.sin(Œ¥), cosŒ¥=Math.cos(Œ¥); const œÜ2 = Math.asin(sinœÜ1*cosŒ¥ + cosœÜ1*sinŒ¥*Math.cos(Œ∏)); const Œª2 = Œª1 + Math.atan2(Math.sin(Œ∏)*sinŒ¥*cosœÜ1, cosŒ¥ - sinœÜ1*Math.sin(œÜ2)); return L.latLng(toDeg(œÜ2), toDeg(Œª2)); }
function flattenLatLngs(latlngs){ if(!Array.isArray(latlngs)) return []; if(latlngs.length>0 && Array.isArray(latlngs[0]) && typeof latlngs[0].lat === 'undefined') return latlngs.flat(); return latlngs; }
function shortestAngleDiff(target,current){ target=((target%360)+360)%360; current=((current%360)+360)%360; return (target - current + 540)%360 - 180; }

/* ---------- ROADS & STARS ---------- */
function clearRoads(){ roads.forEach(r=>{ if(map.hasLayer(r)) map.removeLayer(r); }); roads=[]; roadPixelSegments=[]; }
function clearStars(){ stars.forEach(s=>{ if(s.marker && map.hasLayer(s.marker)) map.removeLayer(s.marker); }); stars=[]; }

//function addRoadFromCoords(coords, style){ const latlngs = coords.map(c => L.latLng(c[1], c[0])); const pl = L.polyline(latlngs, style || { color:'#2b6fd6', weight:4, opacity:0.95 }).addTo(map); roads.push(pl); return pl; }

function addRoadFromCoords(coords, style){
  const latlngs = coords.map(c => L.latLng(c[1], c[0]));
  const opts = style || {
    color: 'rgba(255,0,255,0.6)', 
    weight: 4,
    opacity: 0.5,                    // stroke opacity (multiplikativ zu rgba alpha)
    lineCap: 'round',
    lineJoin: 'round',
    renderer: canvasRenderer       // wenn du canvasRenderer verwendest
  };
  const pl = L.polyline(latlngs, opts).addTo(map);
  roads.push(pl);
  return pl;
}


function samplePointsAlongPath(latlngs, spacingMeters){ const out=[]; if(!latlngs||latlngs.length<2) return out; let traveled=0, nextTarget=spacingMeters; for(let i=0;i<latlngs.length-1;i++){ const a=latlngs[i], b=latlngs[i+1]; const segLen = map.distance(a,b); while(nextTarget <= traveled + segLen){ const t = (nextTarget - traveled)/segLen; out.push(L.latLng(a.lat + (b.lat-a.lat)*t, a.lng + (b.lng-a.lng)*t)); nextTarget += spacingMeters; } traveled += segLen; } return out; }

function placeStarsAll(spacingMeters){ clearStars(); if(roads.length===0) return; let pts = []; for(let ri=0; ri<roads.length; ri++){ const latlngs = flattenLatLngs(roads[ri].getLatLngs()); pts = pts.concat(samplePointsAlongPath(latlngs, spacingMeters)); }
  if(pts.length > MAX_STARS){ const step = Math.ceil(pts.length / MAX_STARS); const filtered = []; for(let i=0;i<pts.length;i+=step) filtered.push(pts[i]); pts = filtered; }
  //pts.forEach(p => { const m = L.circleMarker(p, { radius:6, weight:1, opacity:1, fillOpacity:0.95, interactive:false, renderer: canvasRenderer }).addTo(map); stars.push({marker: m, latlng: p}); });
  
  pts.forEach(p => {
  const m = L.circleMarker(p, {
    radius: 6,
    weight: 1,                // Rand-Breite in px
    color: '#ffdc4d',         // Randfarbe (stroke)
    fillColor: '#ffd83d',     // Innenfarbe (fill) ‚Äî dein Gelb
    fillOpacity: 0.95,
    opacity: 1,
    interactive: false,
    renderer: canvasRenderer
  }).addTo(map);
  stars.push({ marker: m, latlng: p });
});
  
  
}

/* ---------- PIXEL SEGMENTS CACHE ---------- */
function rebuildRoadPixelSegments(){ roadPixelSegments = []; for(let ri=0; ri<roads.length; ri++){ const latlngs = flattenLatLngs(roads[ri].getLatLngs()); const segs = []; for(let i=0;i<latlngs.length-1;i++){ const a = map.latLngToLayerPoint(latlngs[i]); const b = map.latLngToLayerPoint(latlngs[i+1]); segs.push({a,b}); } roadPixelSegments.push(segs); } }
map.on('zoomend moveend resize', ()=>{ rebuildRoadPixelSegments(); });

/* ---------- GEOJSON LOADER ---------- */
geoFileEl.addEventListener('change', (ev)=>{ const f = ev.target.files && ev.target.files[0]; if(!f) return; const reader = new FileReader(); reader.onload = (e)=>{ try{ const j = JSON.parse(e.target.result); if(!j || j.type !== 'FeatureCollection'){ alert('Bitte eine FeatureCollection (GeoJSON) ausw√§hlen.'); return; } clearRoads(); clearStars(); score=0; updateScore(); finished=false; finishOverlay.style.display='none'; let added=0; j.features.forEach(fe=>{ if(!fe.geometry) return; const g=fe.geometry; if(g.type==='LineString'){ addRoadFromCoords(g.coordinates); added++; } else if(g.type==='MultiLineString'){ g.coordinates.forEach(line=> addRoadFromCoords(line)); added++; } }); if(added===0){ alert('Keine LineString-Features gefunden.'); return; } placeStarsAll(STAR_SPACING); rebuildRoadPixelSegments(); if(roads.length>0){ const latlngs = flattenLatLngs(roads[0].getLatLngs()); const start = latlngs[0]; if(start){ carPos = start; map.setView(carPos, MAP_ZOOM, {animate:false}); speed=0; headingDeg=0; displayedAngle=0; } } loaderEl.style.display='none'; alert('GeoJSON geladen: ' + added + ' Feature(s).'); }catch(err){ alert('Fehler beim Einlesen: ' + (err && err.message ? err.message : err)); } }; reader.readAsText(f); });

centerBtn.addEventListener('click', ()=>{ if(roads.length>0) map.fitBounds(L.featureGroup(roads).getBounds().pad(0.2)); else map.setView(STARTPOS, MAP_ZOOM); });
resetBtn.addEventListener('click', ()=>{ clearRoads(); clearStars(); score=0; updateScore(); speed=0; headingDeg=0; displayedAngle=0; if(rotWrapper) rotWrapper.style.transform='rotate(0deg)'; map.setView(STARTPOS, MAP_ZOOM); loaderEl.style.display=''; finished=false; finishOverlay.style.display='none'; });

/* ---------- INPUT ---------- */
const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };

/* ---------- Music menu coordination variables ---------- */
const menuPanel = document.getElementById('menuPanel');
let menuOpen = false;

/* We need to ensure space toggles the menu and when menu is open the
   game input (arrow keys) is ignored. So we integrate space handling here. */
document.addEventListener('keydown', (e)=>{
  const tag = (e.target && e.target.tagName) || '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;

  // Space toggles menu
  if(e.code === 'Space'){
    e.preventDefault();
    toggleMenu();
    return;
  }
  
  // Wenn alle Missionen erledigt sind: Pfeiltasten unterdr√ºcken
if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key) && !missionManager.getState().active) {
  e.preventDefault();
  // keine weitere Aktion ‚Äî Pfeiltasten sind deaktiviert
  return;
}


  // If menu open, ignore movement/states except gear keys
  if(menuOpen) {
    // allow gear changes
    /*
	if (e.key >= '1' && e.key <= '5') {
      currentGear = parseInt(e.key, 10);
      MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
      ACCEL = SPEED_GEARS[currentGear].accel;
      console.log('Gang gewechselt:', currentGear, '-> Speed:', MAX_FORWARD_SPEED, 'Accel:', ACCEL);
    }
	*/
	
	if (e.key >= '1' && e.key <= '9') {
  currentGear = Math.min(9, Math.max(1, parseInt(e.key, 10)));
  MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
  ACCEL = SPEED_GEARS[currentGear].accel;
  console.log('Gang gewechselt:', currentGear, '-> Speed:', MAX_FORWARD_SPEED, 'Accel:', ACCEL);
  updateControlsHelpGear();
}
    // otherwise suppress movement keys
    return;
  }

  // normal game controls
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
    e.preventDefault();
    e.stopPropagation();
    keys[e.key] = true;
  }
  else if (e.key >= '1' && e.key <= '9') {
  currentGear = Math.min(9, Math.max(1, parseInt(e.key, 10)));
  MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
  ACCEL = SPEED_GEARS[currentGear].accel;
   updateControlsHelpGear();
  console.log('Gang gewechselt:', currentGear, '-> Speed:', MAX_FORWARD_SPEED, 'Accel:', ACCEL);
}

else if (e.key && e.key.toLowerCase() === 'f') {
  e.preventDefault();
  // FULLSCREEN: helper + wiring
function isFullscreenFor(el) {
  // returns true if document is fullscreen on the requested element or any element
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}

async function enterFullscreen(el) {
  if (!el) return;
  try {
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    else if (el.mozRequestFullScreen) await el.mozRequestFullScreen();
    else if (el.msRequestFullscreen) await el.msRequestFullscreen();
  } catch (e) { /* some browsers block without gesture; ignore */ }
}

async function exitFullscreen() {
  try {
    if (document.exitFullscreen) await document.exitFullscreen();
    else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
    else if (document.mozCancelFullScreen) await document.mozCancelFullScreen();
    else if (document.msExitFullscreen) await document.msExitFullscreen();
  } catch (e) {}
}

function toggleFullscreenTarget(targetEl = mapDiv) {
  if (isFullscreenFor()) {
    exitFullscreen();
  } else {
    enterFullscreen(targetEl);
  }
}

// Button wiring (after DOM ready)
const fsBtn = document.getElementById('fullscreenBtn');
if (fsBtn) {
  fsBtn.addEventListener('click', (ev) => {
    ev.preventDefault();
    toggleFullscreenTarget(document.documentElement);
  });
}

// update button state on fullscreen changes and resize Leaflet map
function onFullChange() {
  const active = isFullscreenFor();
  if (fsBtn) {
    fsBtn.setAttribute('aria-pressed', String(active));
    fsBtn.textContent = active ? 'Vollbild beenden' : 'Vollbild';
  }
  // allow Leaflet to reflow
  try { setTimeout(()=> map.invalidateSize(), 120); } catch(e) {}
}
document.addEventListener('fullscreenchange', onFullChange);
document.addEventListener('webkitfullscreenchange', onFullChange);
document.addEventListener('mozfullscreenchange', onFullChange);
document.addEventListener('MSFullscreenChange', onFullChange);

}

document.addEventListener('keydown', (e) => {
  const tag = (e.target && e.target.tagName) || '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
  if (e.key && e.key.toLowerCase() === 'f') {
    e.preventDefault();
    toggleFullscreenTarget(document.documentElement);
  }
}, { passive:false });


}, { passive:false });

document.addEventListener('keyup', (e)=>{ if(e.key in keys){ keys[e.key]=false; e.preventDefault(); e.stopPropagation(); } }, { passive:false });

function toggleMenu(){
  menuOpen = !menuOpen;
  menuPanel.classList.toggle('open', menuOpen);
  menuPanel.setAttribute('aria-hidden', String(!menuOpen));
  if(menuOpen){
    // blur active element to avoid accidental key repeats
    try{ (document.activeElement||document.body).blur(); }catch(e){}
    // show hint in menu
    //document.getElementById('miniStatus').textContent = 'Men√º ge√∂ffnet ‚Äî bitte in den Player klicken und Play dr√ºcken.';
  } else {
    //document.getElementById('miniStatus').textContent = 'Warte auf Interaktion‚Ä¶';
  }
}

function updateControlsHelpGear(){
  const g = document.getElementById('controlsHelpGear');
  if (g) g.textContent = currentGear;
}

updateControlsHelpGear();

/* ---------- SOUNDS (Howler optional) ---------- */
let driveSound = null;
try{ driveSound = new Howl({ src: ['assets/mp3/369718__setuniman__in-the-seventies-1o34.mp3'], loop:true, volume:0.3 }); }catch(e){ console.warn('Howler not available or file missing'); }
function startDriving(){ /*if(driveSound && !driveSound.playing()) driveSound.play(); */}
function stopDriving(){ /*if(driveSound) driveSound.stop();*/ }
function playPickupSound(){
  if(!sfxEnabled) return; 
  try{ zzfx(...[,,104,.04,.02,.07,,.8,,138,,,,,,,,.85,.02]); }catch(e){}
}

function playMissionGoalSound(){
  if(!sfxEnabled) return; 
  try{ zzfx(...[0.5,0,311,.08,.21,.16,,2.8,,,374,.19,.08,,,,.17,.99,.29,.1,-1484]);  }catch(e){}
  
}
function playBounceSound(){
  if(!sfxEnabled) return;
  try{ zzfx(0.2,0,200,0.01,0.08,0.14,1,0,0.2,0,0.14); }catch(e){}
}
function playFinishSound(){
  if(!sfxEnabled) return;
  try{ zzfx(0.5,0,440,0.001,0.12,0.35,1,0.2,0.6,0,0.2); }catch(e){}
}



/* ---------- CAR ---------- */
let carPos = L.latLng(STARTPOS[0], STARTPOS[1]); let headingDeg = 0; let displayedAngle = 0; let speed = 0;

/* ----------------------
   Mission Manager
   ---------------------- */
const missionManager = (function(){
  const state = {
    missions: [],
    current: 0,
    markers: [],
    active: false,
    ui: {
      box: document.getElementById('missionBox'),
      title: document.getElementById('missionTitle'),
      distance: document.getElementById('missionDistance'),
      arrow: document.getElementById('missionArrow')
    }
  };

  // berechne Bearing (in Grad) von a -> b (lat/lng)
  function bearingBetween(a, b){
    const œÜ1 = toRad(a.lat), œÜ2 = toRad(b.lat);
    const ŒîŒª = toRad(b.lng - a.lng);
    const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
    const x = Math.cos(œÜ1)*Math.sin(œÜ2) - Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(ŒîŒª);
    return (toDeg(Math.atan2(y,x)) + 360) % 360;
  }

function loadFromUrl(url){
  return fetch(url)
    .then(r => {
      if(!r.ok) throw new Error('Fetch failed: ' + r.status);
      return r.json();
    })
    .then(j => {
      // j.missions || j (array) || []
      const raw = Array.isArray(j.missions) ? j.missions : (Array.isArray(j) ? j : (j.missions ? j.missions : []));
      // normalize each mission into the shape the rest of your code expects:
      // { id, title, description, lat, lng, start, target, radius, marker, onReach }
      state.missions = raw.map(m => {
        const nm = Object.assign({}, m); // shallow copy
        // prefer explicit target.lat/lng if present (new format), else use flat lat/lng
        if(m.target && (m.target.lat !== undefined || m.target.lng !== undefined)){
          nm.lat = Number(m.target.lat);
          nm.lng = Number(m.target.lng);
          nm.target = { lat: Number(m.target.lat), lng: Number(m.target.lng) };
        } else if (m.lat !== undefined && m.lng !== undefined){
          nm.lat = Number(m.lat);
          nm.lng = Number(m.lng);
          nm.target = { lat: nm.lat, lng: nm.lng };
        } else {
          // no usable coordinate ‚Äî leave nulls so we can detect later
          nm.lat = nm.lng = null;
          nm.target = null;
        }

        // also map optional start if present (useful for teleport-on-start)
        if(m.start && (m.start.lat !== undefined || m.start.lng !== undefined)){
          nm.start = { lat: Number(m.start.lat), lng: Number(m.start.lng) };
        } else if(m.startLat !== undefined && m.startLng !== undefined){ // alternative key names
          nm.start = { lat: Number(m.startLat), lng: Number(m.startLng) };
        } else {
          nm.start = nm.start || null;
        }

        nm.radius = Number(m.radius !== undefined ? m.radius : (m.target && m.target.radius) || 10);
        nm.marker = (m.marker === undefined) ? true : Boolean(m.marker);
        nm.onReach = m.onReach || {};
        return nm;
      });

      // set index + active flag and place markers
      state.current = 0;
      state.active = state.missions.length > 0;

      // clear old markers, then place new ones
      clearMarkers();
      if(state.active) placeMarkers();

      // small debug log (remove if you don't want console noise)
      console.log('Missions loaded (normalized):', state.missions);

      return state.missions;
    })
    .catch(err => {
      console.warn('loadFromUrl failed', err);
      throw err;
    });
}


function placeMarkers(){
  clearMarkers();
  state.missions.forEach((m,i)=>{
    // Nur Marker f√ºr die aktuell aktive Mission zeichnen
    if(i === state.current && m.marker){
      const mm = L.circle([m.lat, m.lng], {
        radius: Math.max(6, m.radius),
        color: '#7a00ff',
        weight: 2,
        fill: false,
        interactive: false
      }).addTo(map);
      state.markers.push(mm);
    } else {
      state.markers.push(null);
    }
  });
}


  function clearMarkers(){
    state.markers.forEach(m=>{ if(m && map.hasLayer(m)) map.removeLayer(m); });
    state.markers = [];
  }

  function currentMission(){
    return state.missions[state.current] || null;
  }

function advanceMission(){
  const cm = currentMission();
  if(cm && cm.onReach && cm.onReach.score) {
    score += Number(cm.onReach.score) || 0;
    updateScore();
  }
  playMissionGoalSound();

  // Entferne Marker der aktuellen Mission (falls vorhanden)
  if(state.markers[state.current] && map.hasLayer(state.markers[state.current])){
    try { map.removeLayer(state.markers[state.current]); } catch(e){ /* ignore */ }
    state.markers[state.current] = null;
  }

  // advance index
  state.current++;

  // kleine UI-Nachricht: "Mission abgeschlossen!" ‚Äî bleibt kurz sichtbar
  if(state.ui && state.ui.title){
    state.ui.title.textContent = 'Mission abgeschlossen!';
    setTimeout(()=> {
      const next = currentMission();
      state.ui.title.textContent = next ? next.title : 'Keine Missionen';
    }, 900);
  }

  if(state.current >= state.missions.length){
    // alle Missionen erledigt
    state.active = false;
    // globale finished-Variable (ist in deinem Script vorhanden)
    finished = true;
    finishOverlay.textContent = 'Alle Missionen erledigt üéâ ‚Äî Spiel geschafft!';
    finishOverlay.style.display = 'block';
	missionBox.style.display = 'none';
    playFinishSound();

    // sichere Aufr√§umaktionen
    clearMarkers(); // alle Marker entfernen, sollte schon leer sein, ist aber sicher
    // Deaktiviere Pfeiltasten (falls noch gedr√ºckt)
    keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;

  } else {
    // neue Mission: zeichne deren Marker
    placeMarkers();
    console.log('N√§chste Mission:', currentMission() && currentMission().title);
  }
}


  // Wird in jedem Frame/Loop aufgerufen
  function update(dt){
    if(!state.active) return;
    const cm = currentMission();
    if(!cm) return;
    const target = L.latLng(cm.lat, cm.lng);
    // Distance in meters (Luftlinie)
    const dist = map ? map.distance(carPos, target) : (function(){ return 0; })();

    // Bearing from car -> target
    const b = bearingBetween(carPos, target);

    // relative angle to player heading (target minus heading)
    const rel = shortestAngleDiff(b, headingDeg); // nutzt deine helper shortestAngleDiff

    // Update UI: rotate arrow, show meters
    if(state.ui.arrow) {
      // css rotate: +deg rotates clockwise. We want arrow pointing where target is relative to forward.
      state.ui.arrow.style.transform = `rotate(${rel}deg)`;
    }
    if(state.ui.title) {
      state.ui.title.textContent = cm.title || 'Mission';
    }
    if(state.ui.distance) {
      const mtxt = dist >= 1000 ? (dist/1000).toFixed(2) + ' km' : Math.round(dist) + ' m';
      state.ui.distance.textContent = `${mtxt} ‚Äî ${cm.description || ''}`;
    }

    // Check reach
    if(dist <= (cm.radius || 10)){
      advanceMission();
    }
  }

  // √∂ffentlich API
  return {
    loadFromUrl,
    update,
    getState: ()=>state
  };
})(); // end missionManager





/* ---------- MAIN LOOP (optimized) ---------- */
let lastTime = null; let pickupAccumulator = 0; const PICKUP_CHECK_INTERVAL = 60;
function animate(t){ if(!lastTime) lastTime = t; const dt = Math.min(0.05, (t-lastTime)/1000); lastTime = t;

  // If menuOpen we still animate but we ignore movement keys (already handled in keydown)
  if(keys.ArrowLeft) headingDeg = (headingDeg - 60 * dt + 360) % 360; if(keys.ArrowRight) headingDeg = (headingDeg + 60 * dt) % 360;
  if(keys.ArrowUp) speed += ACCEL * dt; else if(keys.ArrowDown) speed -= ACCEL * dt; else { if(speed>0) speed = Math.max(0, speed - 2.0 * dt); if(speed<0) speed = Math.min(0, speed + 2.0 * dt); }
  speed = Math.min(MAX_FORWARD_SPEED, speed); speed = Math.max(-MAX_FORWARD_SPEED*0.45, speed);

  if(Math.abs(speed) > 0.05) startDriving(); else stopDriving();

  if(Math.abs(speed) > 0.0001){
    const moveMeters = Math.abs(speed) * dt;
    const bearing = speed > 0 ? headingDeg : (headingDeg + 180) % 360;
    const candidate = destinationPoint(carPos.lat, carPos.lng, moveMeters, bearing);

    let inOn=false, inNear=false, inBorder=false;
    if(roadPixelSegments.length>0){ outer: for(let ri=0; ri<roadPixelSegments.length; ri++){ const segs = roadPixelSegments[ri]; for(let si=0; si<segs.length; si++){ const d = L.LineUtil.pointToSegmentDistance(map.latLngToLayerPoint(candidate), segs[si].a, segs[si].b); if(d <= 12){ inOn=true; break outer; } if(d <= 20) inNear=true; if(d <= 28) inBorder=true; } } }

    if(inOn){ carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.96; }
    else if(inNear){ carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.82; }
    else if(inBorder){ carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.72; }
    else { const backDistance = Math.max(1.0, moveMeters * 1.0); const backPos = destinationPoint(carPos.lat, carPos.lng, backDistance, (bearing + 180) % 360); carPos = backPos; map.setView(carPos, map.getZoom(), { animate:false }); const bounceSpeed = Math.max(2.0, Math.abs(speed) * 0.52); speed = -bounceSpeed; carDiv.classList.add('bounce'); setTimeout(()=>carDiv.classList.remove('bounce'), 180); playBounceSound(); }

    pickupAccumulator += dt*1000;
    if(pickupAccumulator >= PICKUP_CHECK_INTERVAL){ pickupAccumulator = 0;
      const centerPt = map.latLngToContainerPoint(carPos);
      const pixelTarget = L.point(centerPt.x + PICKUP_PIXEL_DIST, centerPt.y);
      const latlngTarget = map.containerPointToLatLng(pixelTarget);
      const pickupRadiusMeters = map.distance(carPos, latlngTarget);
      for(let i = stars.length -1; i>=0; i--){ const s = stars[i]; if(!s) continue; const d = map.distance(carPos, s.latlng); if(d <= pickupRadiusMeters){ if(map.hasLayer(s.marker)) map.removeLayer(s.marker); stars.splice(i,1); score += 10; updateScore(); playPickupSound(); } }
    }

    /*
	if(!finished && roads.length>0){ const lastRoadLL = flattenLatLngs(roads[0].getLatLngs()); const lastPoint = lastRoadLL[lastRoadLL.length-1]; if(lastPoint && 
	map.distance(carPos, lastPoint) <= FINISH_DISTANCE_METERS){ finished = true; finishOverlay.style.display = 'block'; playFinishSound(); } }
	*/
	
	
	
	
  }

  if(rotWrapper){ const targetAngle = -headingDeg; const diff = shortestAngleDiff(targetAngle, displayedAngle); const step = diff * (1 - Math.exp(-8 * dt)); displayedAngle += step; if(Math.abs(shortestAngleDiff(targetAngle, displayedAngle)) < 0.02) displayedAngle = ((targetAngle%360)+360)%360; rotWrapper.style.transform = `rotate(${displayedAngle}deg)`; }

  const tiltMax = 12; let angularVelocity = 0; if(keys.ArrowLeft) angularVelocity = -60; if(keys.ArrowRight) angularVelocity = 60; const lean = (angularVelocity / 60) * (Math.min(Math.abs(speed)/MAX_FORWARD_SPEED,1)) * tiltMax; carDiv.style.transform = `translate(-50%,-50%) rotate(${lean}deg)`;
  
  try {
  missionManager.update(dt); // dt ist schon in deinem animate berechnet
} catch(e){ console.warn('missionManager.update failed', e); }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ---------- fallback onRoad ---------- */
function onRoad(latlng, pixelTolerance = 12){ if(roads.length === 0) return false; const p = map.latLngToLayerPoint(latlng); for(let ri=0; ri<roads.length; ri++){ let latlngs = roads[ri].getLatLngs(); if(Array.isArray(latlngs[0]) && latlngs[0] && typeof latlngs[0].lat === 'undefined') latlngs = latlngs.flat(); for(let i=0;i<latlngs.length-1;i++){ const a = map.latLngToLayerPoint(latlngs[i]); const b = map.latLngToLayerPoint(latlngs[i+1]); if(L.LineUtil.pointToSegmentDistance(p,a,b) <= pixelTolerance) return true; } } return false; }

/* ---------- rotate wrapper ---------- */
let rotWrapper = null;
map.whenReady(()=>{ const container = map.getContainer(); const pane = container.querySelector('.leaflet-map-pane'); if(!pane) return; const wrapper = document.createElement('div'); wrapper.className = 'rotate-wrapper'; wrapper.style.position = 'absolute'; wrapper.style.inset = '0'; wrapper.style.willChange = 'transform'; container.insertBefore(wrapper, pane); wrapper.appendChild(pane); rotWrapper = wrapper; rebuildRoadPixelSegments(); alert('‚Ñπ Press SPACE for Menu.'); });

/* ---------- auto-load (optional) ---------- */
(function autoLoadGeoJSON(){ const geojsonDataUrl = 'assets/json/strecken.json'; fetch(geojsonDataUrl).then(res => { if(!res.ok) throw new Error('not found'); return res.json(); }).then(j => { if(!j || j.type !== 'FeatureCollection') return; clearRoads(); clearStars(); score=0; updateScore(); finished=false; finishOverlay.style.display='none'; let added=0; j.features.forEach(fe=>{ if(!fe.geometry) return; const g=fe.geometry; if(g.type==='LineString'){ addRoadFromCoords(g.coordinates); added++; } else if(g.type==='MultiLineString'){ g.coordinates.forEach(line=> addRoadFromCoords(line)); added++; } }); if(added===0) return; placeStarsAll(STAR_SPACING); rebuildRoadPixelSegments(); if(roads.length>0){ const latlngs = flattenLatLngs(roads[0].getLatLngs()); const start = latlngs[0]; if(start){ carPos = start; map.setView(carPos, MAP_ZOOM, {animate:false}); speed=0; headingDeg = 90;
displayedAngle = -headingDeg;
if (rotWrapper) rotWrapper.style.transform = `rotate(${displayedAngle}deg)`; } } loaderEl.style.display='none'; console.log('Auto-GeoJSON geladen: ' + added + ' Feature(s)'); }).catch(()=>{}); })();

// auto-load missions (einfacher)
(function autoLoadMissions(){
  const missionsUrl = 'assets/json/missions.json';
  missionManager.loadFromUrl(missionsUrl).then(ms=>{
    console.log('Missions geladen:', ms.length);
  }).catch(err=>{
    console.warn('missionManager load failed', err);
  });
})();




/* ---- Persistente Audio-Einstellungen (global / simple) ---- */
const MUSIC_KEY = 'oldenburg_kart_music'; // '1' = Wunsch: an, '0' = Wunsch: aus
const SFX_KEY   = 'oldenburg_kart_sfx';   // '1' = an, '0' = aus

// initial values (load from localStorage; default true)
let musicDesired = (localStorage.getItem(MUSIC_KEY) !== '0'); // true unless explicitly '0'
let sfxEnabled   = (localStorage.getItem(SFX_KEY)   !== '0'); // true unless explicitly '0'

// update UI helper (safe if elements not present yet)
function setButtonState(btn, enabled, labelOn, labelOff){
  if(!btn) return;
  btn.setAttribute('aria-pressed', String(Boolean(enabled)));
  btn.textContent = enabled ? labelOn : labelOff;
}

// wire up buttons if present (menu buttons created in DOM)
document.addEventListener('DOMContentLoaded', ()=> {
  const sfxBtn = document.getElementById('sfxBtn');
  const musicBtn = document.getElementById('musicBtn');

  setButtonState(sfxBtn, sfxEnabled, 'SFX: An', 'SFX: Aus');
  setButtonState(musicBtn, musicDesired, 'Musik: An', 'Musik: Aus');

  if(sfxBtn){
    sfxBtn.addEventListener('click', (ev)=>{
      ev.preventDefault();
      sfxEnabled = !sfxEnabled;
      localStorage.setItem(SFX_KEY, sfxEnabled ? '1' : '0');
      setButtonState(sfxBtn, sfxEnabled, 'SFX: An', 'SFX: Aus');
      // optional visual feedback
      sfxBtn.classList.toggle('menu-action', true);
    });
  }

  if(musicBtn){
    musicBtn.addEventListener('click', async (ev)=>{
      ev.preventDefault();
      musicDesired = !musicDesired;
      localStorage.setItem(MUSIC_KEY, musicDesired ? '1' : '0');
      setButtonState(musicBtn, musicDesired, 'Musik: An', 'Musik: Aus');
      // if user already interacted with player, toggle play/pause if desired
      try{ if(window.OldenburgAudio && typeof window.OldenburgAudio.applyMusicPreference === 'function'){
        window.OldenburgAudio.applyMusicPreference(musicDesired);
      }}catch(e){}
    });
  }
});

// --- S-Taste: SFX an/aus (case-insensitive) ---
document.addEventListener('keydown', (e) => {
  const tag = (e.target && e.target.tagName) || '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
  if (!e.key) return;
  if (e.key.toLowerCase() === 's') {
    e.preventDefault();
    // toggle and persist
    sfxEnabled = !sfxEnabled;
    try { localStorage.setItem(SFX_KEY, sfxEnabled ? '1' : '0'); } catch (err) {}
    // update button UI if present
    const sfxBtn = document.getElementById('sfxBtn');
    if (sfxBtn) setButtonState(sfxBtn, sfxEnabled, 'SFX: An', 'SFX: Aus');
    // small audible feedback when enabling (won't play if disabled)
    if (sfxEnabled) {
      try { playPickupSound(); } catch (err) {}
    }
    console.log('SFX toggled ->', sfxEnabled ? 'AN' : 'AUS');
  }
}, { passive: false });





/* ============================
   Musik-Menu (kapsel, keine globalen Konflikte)
   - Space toggled (siehe oben).
   - Resume / save position / M toggle works like in original musik.js,
     aber lokal scoped.
   ============================ */

(function MusicMenuModule(){
  const mixIframe = document.getElementById('mixcloudPlayer');
  const iframeOverlay = document.getElementById('iframeOverlay');
  const overlayText = document.getElementById('overlayText');
  const miniStatus = document.getElementById('miniStatus');

  let widget = null;
  let widgetReady = false;
  let userInteracted = false;
  let isPlaying = false;
  let pendingSeekSeconds = null;
  let _saveInterval = null;

  const STORAGE_KEY = 'mixcloud_pos_' + encodeURIComponent(mixIframe.src);

  // init widget safely
  try{
    widget = Mixcloud.PlayerWidget(mixIframe);
    widget.ready.then(()=>{
      widgetReady = true;
      try{
        widget.events.play.on(()=>{ isPlaying = true; confirmPlay('widget.events.play'); console.log("playing.."); });
        widget.events.pause.on(()=>{ isPlaying = false; });
		widget.events.seek.on(() => {
		console.log("seeking...");
      // small delay so widget finished internal updates, then reclaim focus
      setTimeout(() => returnFocusToMap(), 60);
    });
        widget.events.ended.on(()=>{ localStorage.removeItem(STORAGE_KEY); //miniStatus.textContent = 'Track beendet ‚Äî gespeicherte Position gel√∂scht';
		});
      }catch(e){ console.warn('events unavailable', e); }

      // load saved pos (pending)
      const savedRaw = localStorage.getItem(STORAGE_KEY);
      const saved = savedRaw ? parseFloat(savedRaw) : 0;
      if (saved && !Number.isNaN(saved) && saved > 0){ pendingSeekSeconds = saved; console.log('pending saved pos', pendingSeekSeconds); }

      // start periodic saving
      startSavingPositionEverySecond();
    }).catch(err=>console.warn('widget.ready rejected', err));
  }catch(e){ console.warn('widget init failed', e); }

  // Detect clicks in iframe area: capture-phase pointerdown/touchstart global, check coords against iframe rect
  function onGlobalPointerDown(e){
    const tag = (e.target && e.target.tagName) || '';
    if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
    const rect = mixIframe.getBoundingClientRect();
    const x = (typeof e.clientX === 'number') ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
    const y = (typeof e.clientY === 'number') ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
    if (typeof x !== 'number' || typeof y !== 'number') return;
    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom){
      startPlayDetection('pointerdown-in-iframe');
    }
  }
  document.addEventListener('pointerdown', onGlobalPointerDown, true);
  document.addEventListener('touchstart', onGlobalPointerDown, true);

  try{ mixIframe.addEventListener('focus', ()=>{ startPlayDetection('iframe-focus'); }); }catch(e){}
  window.addEventListener('blur', ()=>{ startPlayDetection('window-blur'); });

  const PLAY_POLL_INTERVAL = 350; const PLAY_DETECT_TIMEOUT = 15000;
  let _playDetectPoll = null; let _playDetectTimer = null; let _widgetPlayHandler = null;

  function startPlayDetection(source){
    if (_playDetectPoll) return;
    //miniStatus.textContent = 'Erkenne Play (trigger: ' + source + ')';
    try{ if (widget && widget.events && widget.events.play && !_widgetPlayHandler){ _widgetPlayHandler = ()=> confirmPlay('widget.events.play'); widget.events.play.on(_widgetPlayHandler); } }catch(e){}
    const start = Date.now();
    _playDetectPoll = setInterval(async ()=>{
      if (!widgetReady) return;
      try{
        const pos = await widget.getPosition();
        if (typeof pos === 'number' && isFinite(pos) && pos > 0.5){ confirmPlay('getPosition>0.5s (poll)'); }
      }catch(err){}
      if (Date.now() - start > PLAY_DETECT_TIMEOUT){ stopPlayDetection(); //miniStatus.textContent = 'Kein Play erkannt (timeout)';
	  }
    }, PLAY_POLL_INTERVAL);
    _playDetectTimer = setTimeout(()=>stopPlayDetection(), PLAY_DETECT_TIMEOUT);
	
  }
  function stopPlayDetection(){ if (_playDetectPoll){ clearInterval(_playDetectPoll); _playDetectPoll = null; } if (_playDetectTimer){ clearTimeout(_playDetectTimer); _playDetectTimer = null; } }

  async function confirmPlay(detectedVia){
  
  
  if(menuOpen){
	//console.log("play confirmed.");
	setTimeout(() => returnFocusToMap(), 60);
  }
  
  
    if (userInteracted) return;
    userInteracted = true; isPlaying = true;
    overlayText.textContent = 'Play gedr√ºckt. Mit der Taste M kannst du nun die Musik an und aus machen.';
    //miniStatus.textContent = 'Play gedr√ºckt (detected via: ' + detectedVia + ')';
	returnFocusToMap();
	
	// minimaler, robuster Ablauf (nur als Snippet)
// neu: robuster helper-Aufruf
returnFocusToMap();
// optional: Men√º schlie√üen, wenn du das m√∂chtest
menuPanel.classList.remove('open'); menuOpen = false;
	
    await tryPendingSeekAfterUserInteracted();
    stopPlayDetection();
  }

  async function attemptSeek(seconds) {
  console.log("trying focus...");
  if (!widgetReady || !widget || typeof widget.seek !== 'function') return false;
  try {
    const res = await widget.seek(seconds);
    // Mixcloud gibt manchmal `false` bei Fehlern zur√ºck ‚Äî alles andere behandeln wir als Erfolg
    if (res === false) return false;

    // Seek erfolgreich: gespeicherte Position zur√ºcksetzen
    pendingSeekSeconds = null;

    // Fokus zur√ºck zur Map holen (robustes Helper mit Retries)
    try { returnFocusToMap(); } catch (e) { /* ignore */ }

    return true;
  } catch (err) {
    console.warn('widget.seek failed', err);
    return false;
  }
}

  async function tryPendingSeekAfterUserInteracted(){ if (!widgetReady) return; if (!pendingSeekSeconds) return; const ok = await attemptSeek(pendingSeekSeconds); if (ok) return; const start = Date.now(); const timeout = 10000; const poll = setInterval(async ()=>{ if (!widgetReady) return; try{ const pos = await widget.getPosition(); if (typeof pos === 'number' && isFinite(pos) && pos > 0.1){ const ok2 = await attemptSeek(pendingSeekSeconds); if (ok2){ clearInterval(poll); } } }catch(e){} if (Date.now()-start > timeout){ clearInterval(poll); } }, 600); }

  function startSavingPositionEverySecond(){ if (_saveInterval) return; _saveInterval = setInterval(async ()=>{ if (!widgetReady) return; try{ const pos = await widget.getPosition(); if (typeof pos === 'number' && isFinite(pos)){ localStorage.setItem(STORAGE_KEY, String(Math.floor(pos))); } }catch(e){} }, 1000); }
  function stopSavingPosition(){ if (_saveInterval){ clearInterval(_saveInterval); _saveInterval = null; } }

  async function togglePlayPauseMusic(){ if (!widgetReady) return; if (!userInteracted){ alert('Bitte zuerst Play im Player dr√ºcken.'); return; } try{ if (typeof widget.togglePlay === 'function'){ await widget.togglePlay(); return; } if (isPlaying) await widget.pause(); else await widget.play(); }catch(err){} }

  // expose M toggle and menu-key globally by listening for keydown on document
  document.addEventListener('keydown', (e)=>{
    const tag = (e.target && e.target.tagName) || '';
    if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
    if (e.key && e.key.toLowerCase() === 'm'){
      e.preventDefault();
      togglePlayPauseMusic();
    }
  }, {passive:false});

  // load pending saved pos from storage immediately (but don't seek until user interacts)
  try{ const savedRaw = localStorage.getItem(STORAGE_KEY); const saved = savedRaw ? parseFloat(savedRaw) : 0; if (saved && !Number.isNaN(saved) && saved > 0){ pendingSeekSeconds = saved; console.log('pending saved pos', pendingSeekSeconds); } }catch(e){}
  
  
  // A: Helper ‚Äî INSIDE MusicMenuModule so mixIframe and map are in scope
// state var (MusicMenuModule scope)
let _restorePointerHandler = null;

function enableIframePointerEvents() {
  try { mixIframe.style.pointerEvents = ''; } catch(e) {}
  if (_restorePointerHandler) {
    document.removeEventListener('pointerdown', _restorePointerHandler, true);
    _restorePointerHandler = null;
  }
}

// robustes returnFocusToMap: kurz deaktivieren, dann re-enable on next pointerdown OR timeout
function returnFocusToMap(attempts = 8, interval = 80) {
  try { mixIframe.blur(); } catch(e){}
  const cont = map.getContainer();
  if (typeof cont.tabIndex === 'undefined' || cont.tabIndex < 0) cont.tabIndex = 0;
  let tries = 0;
  const id = setInterval(()=> {
    try { cont.focus(); } catch(e) {}
    tries++; if (tries >= attempts) clearInterval(id);
  }, interval);
}


  // cleanup on unload
  window.addEventListener('beforeunload', ()=>{ stopSavingPosition(); });
  
  
  
})(); // end MusicMenuModule

// FULLSCREEN: helper + wiring
function isFullscreenFor(el) {
  // returns true if document is fullscreen on the requested element or any element
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}

async function enterFullscreen(el) {
  if (!el) return;
  try {
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    else if (el.mozRequestFullScreen) await el.mozRequestFullScreen();
    else if (el.msRequestFullscreen) await el.msRequestFullscreen();
  } catch (e) { /* some browsers block without gesture; ignore */ }
}

async function exitFullscreen() {
  try {
    if (document.exitFullscreen) await document.exitFullscreen();
    else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
    else if (document.mozCancelFullScreen) await document.mozCancelFullScreen();
    else if (document.msExitFullscreen) await document.msExitFullscreen();
  } catch (e) {}
}

function toggleFullscreenTarget(targetEl = mapDiv) {
  if (isFullscreenFor()) {
    exitFullscreen();
  } else {
    enterFullscreen(targetEl);
  }
}

// Button wiring (after DOM ready)
const fsBtn = document.getElementById('fullscreenBtn');
if (fsBtn) {
  fsBtn.addEventListener('click', (ev) => {
    ev.preventDefault();
    toggleFullscreenTarget(document.documentElement); // vollbild f√ºr die Karte
  });
}

// update button state on fullscreen changes and resize Leaflet map
function onFullChange() {
  const active = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
  if (fsBtn) {
    fsBtn.setAttribute('aria-pressed', String(active));
    fsBtn.textContent = active ? 'Vollbild beenden' : 'Vollbild';
  }
  // Leaflet neu rechnen
  try { setTimeout(()=> map.invalidateSize(), 120); } catch(e){}
}

document.addEventListener('fullscreenchange', onFullChange);
document.addEventListener('webkitfullscreenchange', onFullChange);
document.addEventListener('mozfullscreenchange', onFullChange);
document.addEventListener('MSFullscreenChange', onFullChange);








</script>
</body>
</html>
