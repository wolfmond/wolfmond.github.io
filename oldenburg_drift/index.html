<!doctype html>
<!-- 

All rights reserved. At least at this very moment; I'm planning to realease this game into the Creative Commons, but please let me finish it first. It's still super buggy and I have a lot of Ideas. It's playable, yet; but don't expect too much. This is merely a draft, yet. Greetz, Wolfmond

Current Version: 2025-09-22_23.46

-->
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Oldenburg Kart ‚Äî Optimized + Music Menu</title>
<script>
const message = "‚ö†Ô∏è This is a highly experimental Prototype. Not yet intended for public use. All Rights Reserved. No Warranties. Use this software at your own risk. This website can be played with arrow keys on your keyboard on a Laptop/PC. Tested with Chrome & Brave. In my Tests: Runs best in Chrome Browser. Language (yet): GERMAN";

// Zeigt eine Best√§tigungsbox an
if (!confirm(message)) {
  // Wenn der Nutzer auf "Abbrechen" klickt
  window.location.href = "about:blank";
}
</script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  :root{
	--bg:#222222;
	--panel:#fff;
	--muted:#666;

 --car-top:    #7a00ff;    /* violet */
  --car-bottom: #160032;    /* deep indigo */
  --car-accent: #ff9ee7;    /* neon pink for triangle */
  --car-rim:    rgba(255,255,255,0.12);
  --car-glow:   rgba(122,0,255,0.18);
  
  
  }
  html,body,#map { height:100%; margin:0; padding:0; font-family: system-ui, Arial, sans-serif; }
  #map { position:relative; overflow:hidden; background:#e7eef8; }

  /* --- Car UI --- */
  /* circle / body */
.car-center{
  position: absolute;
  z-index: 12000;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 40px;
  height: 40px;
  border-radius: 50%;
background: radial-gradient(circle at center, var(--car-top), var(--car-bottom));

  border: 2px solid var(--car-rim);
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  /* multi-layered glow + inner subtle sheen */
  box-shadow:box-shadow:
  0 0 18px rgba(0,0,0,0.6),
  0 0 26px var(--car-glow),
  0 0 6px rgba(255,158,231,0.06) inset;
  transition: transform 160ms ease, box-shadow 160ms ease, background 220ms ease;
}

/* slight bounce look */
.car-center.bounce{
  transform: translate(-50%,-48%) scale(1.02);
  box-shadow:
    0 6px 14px rgba(0,0,0,0.65),
    0 10px 30px var(--car-glow);
}

/* make SVG polygon crisp and enable color transitions */
.car-center svg { width: 22px; height: 22px; display:block; }
.car-center polygon {
  transition: fill 180ms ease, stroke 180ms ease, transform 160ms ease;
  filter: drop-shadow(0 4px 10px rgba(122,0,255,0.18));
}

  .score { position:absolute; top:12px; right:12px; z-index:14000; background: rgba(255,255,255,0.95); padding:8px 12px; border-radius:8px; font-weight:700; display:flex; gap:12px; align-items:center; box-shadow: 0 6px 18px rgba(0,0,0,0.08); }
  .loader { position:absolute; top:12px; left:12px; z-index:14000; background: rgba(255,255,255,0.96); padding:10px; border-radius:8px; font-size:13px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); min-width:220px; }
  .finish-overlay { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:16000; background: rgba(255,255,255,0.96); padding:18px 22px; border-radius:12px; box-shadow: 0 10px 30px rgba(0,0,0,0.12); display:none; font-weight:800; }

  /* --- Music menu (z-index high) --- */
  .menu-panel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%) scale(0.98);width:min(860px,95vw);background:var(--panel);box-shadow:0 20px 60px rgba(0,0,0,0.12);border-radius:12px;padding:18px;opacity:0;pointer-events:none;transition:opacity .22s ease, transform .22s ease;z-index:20050}
  .menu-panel.open{opacity:1;transform:translate(-50%,-50%) scale(1);pointer-events:auto}
  .menu-inner{display:flex;flex-direction:column;gap:12px}
  .iframe-wrap{position:relative;border-radius:10px;overflow:hidden;border:1px solid rgba(0,0,0,0.06)}
  #mixcloudPlayer{width:100%;height:160px;border:0;display:block}
  /* overlay text sits visually over iframe but does not block clicks */
  .iframe-overlay{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(255,255,255,0.0),rgba(255,255,255,0.0));pointer-events:none}
  .overlay-text{background:rgba(255,255,255,0.02);padding:10px 14px;border-radius:8px;font-weight:600;color:#333}
  .mini-status{font-size:0.9rem;color:var(--muted);text-align:center;margin-top:6px}

  @media (max-width:480px){ #mixcloudPlayer{height:120px} .menu-panel{padding:12px} }
  
  .controls-help { font-size:0.92rem; color:var(--muted); margin-top:10px; text-align:center; display:flex; flex-direction:column; gap:6px; }
.help-title { font-weight:700; color:#222; margin-bottom:2px; }
.help-list { display:flex; flex-direction:column; gap:6px; align-items:center; }
.controls-help kbd {
  display:inline-block; padding:4px 7px; border-radius:6px; background:#fafafa;
  border:1px solid rgba(0,0,0,0.06); box-shadow: inset 0 -1px 0 rgba(0,0,0,0.03);
  font-weight:700; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
}
@media (max-width:480px){ .controls-help { font-size:0.85rem; } .controls-help kbd{ padding:3px 6px } }

.menu-action{
  background: #fff;
  border: 1px solid rgba(0,0,0,0.06);
  padding: 8px 12px;
  border-radius: 10px;
  font-weight:700;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  cursor: pointer;
}
.menu-action[aria-pressed="true"]{
  background: #222;
  color:#fff;
  border-color: rgba(0,0,0,0.12);
}

@media (max-width:480px){ .menu-action{ padding:6px 10px } }

#fullscreenBtn {
	border: 1px solid black;	
}

  
  .leaflet-tile { filter: hue-rotate(var(--map-hue, 0deg)) saturate(0.3) contrast(1.03) brightness(1.02) invert(1); }
  
  
</style>
</head>
<body>
  <div id="map"></div>

<!--  <div class="car-center" id="carDiv" title="Dein Wagen"><div class="car-arrow" id="carArrow"></div></div>-->

<div class="car-center" id="carDiv" title="Dein Wagen">
  <!-- SVG triangle: fill = accent, stroke = soft outline -->
  <svg width="22" height="22" viewBox="0 0 100 100" aria-hidden="true" focusable="false">
    <polygon id="carTriangle" points="50,8 86,86 14,86"
      fill="var(--car-accent,#ff9ee7)"
      stroke="rgba(255,255,255,0.14)"
      stroke-width="3"
      stroke-linejoin="round"/>
  </svg>
</div>

  <div class="loader" id="loader">
    <div style="font-weight:700">Oldenburg Kart ‚Äî Optimized</div>
    <div class="small">Lade ein GeoJSON (FeatureCollection mit LineString). Standard Sterne-Abstand: <strong>100 m</strong>.</div>
    <input id="geoFile" type="file" accept="application/json,application/geo+json" />
    <div style="margin-top:8px" class="row"><button id="centerBtn" style="min-width:80px">Zentrieren</button> <button id="resetBtn" style="min-width:80px">Reset</button></div>
  </div>

  <div class="score"><div>Score: <span id="score">0</span></div><div id="hs">Highscore: 0</div></div>
  <div class="finish-overlay" id="finishOverlay">Strecke beendet üéâ</div>

  <!-- Musik-Menu (Space toggled) -->
  <div class="menu-panel" id="menuPanel" aria-hidden="true">
    <div class="menu-inner">
      <div class="iframe-wrap">
        <!-- Passe das feed URL nach Bedarf an -->
        <iframe id="mixcloudPlayer" src="https://www.mixcloud.com/widget/iframe/?feed=https://www.mixcloud.com/DarknessForever/neonvisions1-07ef66c492e097d6b34282657dbfa5bd/&hide_cover=1&hide_tracklist=1&mini=1" allow="encrypted-media"></iframe>
        <div class="iframe-overlay" id="iframeOverlay"><div class="overlay-text" id="overlayText">Einmal in den Player klicken und Play dr√ºcken</div></div>
      </div>
      <!--<div class="mini-status" id="miniStatus">Warte auf Interaktion‚Ä¶</div>-->
	  
	  <!-- Vollbild-Button: direkt unter den Hilfetext einf√ºgen -->
<div style="display:flex;justify-content:center;margin-top:8px">
  <button id="fullscreenBtn" class="menu-action" type="button" aria-pressed="false">Vollbild</button>
</div>

	  <div class="controls-help" id="controlsHelp" aria-live="polite">
  <div class="help-title">Tastenbelegung</div>
  <div class="help-list">
    <div><kbd>1‚Äì9</kbd> Speed √§ndern ‚Äî aktueller Gang: <strong id="controlsHelpGear">1</strong></div>
    <div><kbd>F</kbd> Vollbild an/aus</div>
    <div><kbd>M</kbd> Musik an/aus</div>
    <div><kbd>Leertaste</kbd> Men√º √∂ffnen / schlie√üen</div>
  </div>
</div>

    </div>
  </div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/zzfx@1.3.2/ZzFXMicro.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

<!-- Mixcloud widget API (f√ºr PlayerWidget) -->
<script src="https://widget.mixcloud.com/media/js/widgetApi.js"></script>

<script>
/* ============================
   Integrierte Spiel-Logik (wie vorher, optimiert)
   ============================ */

/* ---------- CONFIG ---------- */
const MAP_ZOOM = 19;
const MAP_HUE_ROTATION = 90;
const STAR_SPACING = 100; // wichtig: nicht 10!
const MAX_STARS = 800;
const PICKUP_PIXEL_DIST = 14;
const FINISH_DISTANCE_METERS = 8;
//const SPEED_GEARS = {1:{speed:15,accel:10},2:{speed:25,accel:15},3:{speed:35,accel:20},4:{speed:45,accel:25},5:{speed:60,accel:30}};
const SPEED_GEARS = {
  1: { speed: 15,  accel: 10 },
  2: { speed: 25,  accel: 15 },
  3: { speed: 35,  accel: 20 },
  4: { speed: 45,  accel: 25 },
  5: { speed: 60,  accel: 30 },
  6: { speed: 75,  accel: 35 },
  7: { speed: 95,  accel: 45 },
  8: { speed: 120, accel: 60 },
  9: { speed: 150, accel: 80 }
};
let currentGear = 1; 
currentGear = Math.min(9, Math.max(1, Number(currentGear) || 1));

let MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed; let ACCEL = SPEED_GEARS[currentGear].accel;
const STARTPOS = [53.143559, 8.22416];

/* ---------- MAP ---------- */
const map = L.map('map', { keyboard:false, zoomControl:false, minZoom:MAP_ZOOM, maxZoom:MAP_ZOOM, scrollWheelZoom:false, doubleClickZoom:false, touchZoom:false, dragging:false, boxZoom:false }).setView(STARTPOS, MAP_ZOOM);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { minZoom:MAP_ZOOM, maxZoom:MAP_ZOOM, keepBuffer:2, attribution: '<a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noreferrer">¬© OpenStreetMap contributors</a>' }).addTo(map);
document.documentElement.style.setProperty('--map-hue', MAP_HUE_ROTATION + 'deg');
const canvasRenderer = L.canvas({ padding: 0.5 });

/* ---------- DOM ---------- */
const mapDiv = document.getElementById('map');
const carDiv = document.getElementById('carDiv');
const loaderEl = document.getElementById('loader');
const geoFileEl = document.getElementById('geoFile');
const centerBtn = document.getElementById('centerBtn');
const resetBtn = document.getElementById('resetBtn');
const scoreEl = document.getElementById('score');
const hsEl = document.getElementById('hs');
const finishOverlay = document.getElementById('finishOverlay');

/* ---------- STATE ---------- */
let roads = [], stars = [], roadPixelSegments = [], score = 0, finished = false;
hsEl.textContent = 'Highscore: ' + (localStorage.getItem('oldenburg_kart_highscore_custom')||0);
function updateScore(){ scoreEl.textContent = score; const prev = Number(localStorage.getItem('oldenburg_kart_highscore_custom')||0); if(score>prev){ localStorage.setItem('oldenburg_kart_highscore_custom', score); hsEl.textContent = 'Highscore: ' + score; } }

/* ---------- HELPERS ---------- */
const R = 6378137; function toRad(d){return d*Math.PI/180;} function toDeg(r){return r*180/Math.PI;}
function destinationPoint(lat, lon, distanceMeters, bearingDeg){ const Œ¥ = distanceMeters / R; const Œ∏ = toRad(bearingDeg); const œÜ1 = toRad(lat); const Œª1 = toRad(lon); const sinœÜ1=Math.sin(œÜ1), cosœÜ1=Math.cos(œÜ1); const sinŒ¥=Math.sin(Œ¥), cosŒ¥=Math.cos(Œ¥); const œÜ2 = Math.asin(sinœÜ1*cosŒ¥ + cosœÜ1*sinŒ¥*Math.cos(Œ∏)); const Œª2 = Œª1 + Math.atan2(Math.sin(Œ∏)*sinŒ¥*cosœÜ1, cosŒ¥ - sinœÜ1*Math.sin(œÜ2)); return L.latLng(toDeg(œÜ2), toDeg(Œª2)); }
function flattenLatLngs(latlngs){ if(!Array.isArray(latlngs)) return []; if(latlngs.length>0 && Array.isArray(latlngs[0]) && typeof latlngs[0].lat === 'undefined') return latlngs.flat(); return latlngs; }
function shortestAngleDiff(target,current){ target=((target%360)+360)%360; current=((current%360)+360)%360; return (target - current + 540)%360 - 180; }

/* ---------- ROADS & STARS ---------- */
function clearRoads(){ roads.forEach(r=>{ if(map.hasLayer(r)) map.removeLayer(r); }); roads=[]; roadPixelSegments=[]; }
function clearStars(){ stars.forEach(s=>{ if(s.marker && map.hasLayer(s.marker)) map.removeLayer(s.marker); }); stars=[]; }

//function addRoadFromCoords(coords, style){ const latlngs = coords.map(c => L.latLng(c[1], c[0])); const pl = L.polyline(latlngs, style || { color:'#2b6fd6', weight:4, opacity:0.95 }).addTo(map); roads.push(pl); return pl; }

function addRoadFromCoords(coords, style){
  const latlngs = coords.map(c => L.latLng(c[1], c[0]));
  const opts = style || {
    color: 'rgba(255,0,255,0.6)', 
    weight: 4,
    opacity: 0.5,                    // stroke opacity (multiplikativ zu rgba alpha)
    lineCap: 'round',
    lineJoin: 'round',
    renderer: canvasRenderer       // wenn du canvasRenderer verwendest
  };
  const pl = L.polyline(latlngs, opts).addTo(map);
  roads.push(pl);
  return pl;
}


function samplePointsAlongPath(latlngs, spacingMeters){ const out=[]; if(!latlngs||latlngs.length<2) return out; let traveled=0, nextTarget=spacingMeters; for(let i=0;i<latlngs.length-1;i++){ const a=latlngs[i], b=latlngs[i+1]; const segLen = map.distance(a,b); while(nextTarget <= traveled + segLen){ const t = (nextTarget - traveled)/segLen; out.push(L.latLng(a.lat + (b.lat-a.lat)*t, a.lng + (b.lng-a.lng)*t)); nextTarget += spacingMeters; } traveled += segLen; } return out; }

function placeStarsAll(spacingMeters){ clearStars(); if(roads.length===0) return; let pts = []; for(let ri=0; ri<roads.length; ri++){ const latlngs = flattenLatLngs(roads[ri].getLatLngs()); pts = pts.concat(samplePointsAlongPath(latlngs, spacingMeters)); }
  if(pts.length > MAX_STARS){ const step = Math.ceil(pts.length / MAX_STARS); const filtered = []; for(let i=0;i<pts.length;i+=step) filtered.push(pts[i]); pts = filtered; }
  //pts.forEach(p => { const m = L.circleMarker(p, { radius:6, weight:1, opacity:1, fillOpacity:0.95, interactive:false, renderer: canvasRenderer }).addTo(map); stars.push({marker: m, latlng: p}); });
  
  pts.forEach(p => {
  const m = L.circleMarker(p, {
    radius: 6,
    weight: 1,                // Rand-Breite in px
    color: '#ffdc4d',         // Randfarbe (stroke)
    fillColor: '#ffd83d',     // Innenfarbe (fill) ‚Äî dein Gelb
    fillOpacity: 0.95,
    opacity: 1,
    interactive: false,
    renderer: canvasRenderer
  }).addTo(map);
  stars.push({ marker: m, latlng: p });
});
  
  
}

/* ---------- PIXEL SEGMENTS CACHE ---------- */
function rebuildRoadPixelSegments(){ roadPixelSegments = []; for(let ri=0; ri<roads.length; ri++){ const latlngs = flattenLatLngs(roads[ri].getLatLngs()); const segs = []; for(let i=0;i<latlngs.length-1;i++){ const a = map.latLngToLayerPoint(latlngs[i]); const b = map.latLngToLayerPoint(latlngs[i+1]); segs.push({a,b}); } roadPixelSegments.push(segs); } }
map.on('zoomend moveend resize', ()=>{ rebuildRoadPixelSegments(); });

/* ---------- GEOJSON LOADER ---------- */
geoFileEl.addEventListener('change', (ev)=>{ const f = ev.target.files && ev.target.files[0]; if(!f) return; const reader = new FileReader(); reader.onload = (e)=>{ try{ const j = JSON.parse(e.target.result); if(!j || j.type !== 'FeatureCollection'){ alert('Bitte eine FeatureCollection (GeoJSON) ausw√§hlen.'); return; } clearRoads(); clearStars(); score=0; updateScore(); finished=false; finishOverlay.style.display='none'; let added=0; j.features.forEach(fe=>{ if(!fe.geometry) return; const g=fe.geometry; if(g.type==='LineString'){ addRoadFromCoords(g.coordinates); added++; } else if(g.type==='MultiLineString'){ g.coordinates.forEach(line=> addRoadFromCoords(line)); added++; } }); if(added===0){ alert('Keine LineString-Features gefunden.'); return; } placeStarsAll(STAR_SPACING); rebuildRoadPixelSegments(); if(roads.length>0){ const latlngs = flattenLatLngs(roads[0].getLatLngs()); const start = latlngs[0]; if(start){ carPos = start; map.setView(carPos, MAP_ZOOM, {animate:false}); speed=0; headingDeg=0; displayedAngle=0; } } loaderEl.style.display='none'; alert('GeoJSON geladen: ' + added + ' Feature(s).'); }catch(err){ alert('Fehler beim Einlesen: ' + (err && err.message ? err.message : err)); } }; reader.readAsText(f); });

centerBtn.addEventListener('click', ()=>{ if(roads.length>0) map.fitBounds(L.featureGroup(roads).getBounds().pad(0.2)); else map.setView(STARTPOS, MAP_ZOOM); });
resetBtn.addEventListener('click', ()=>{ clearRoads(); clearStars(); score=0; updateScore(); speed=0; headingDeg=0; displayedAngle=0; if(rotWrapper) rotWrapper.style.transform='rotate(0deg)'; map.setView(STARTPOS, MAP_ZOOM); loaderEl.style.display=''; finished=false; finishOverlay.style.display='none'; });

/* ---------- INPUT ---------- */
const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };

/* ---------- Music menu coordination variables ---------- */
const menuPanel = document.getElementById('menuPanel');
let menuOpen = false;

/* We need to ensure space toggles the menu and when menu is open the
   game input (arrow keys) is ignored. So we integrate space handling here. */
document.addEventListener('keydown', (e)=>{
  const tag = (e.target && e.target.tagName) || '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;

  // Space toggles menu
  if(e.code === 'Space'){
    e.preventDefault();
    toggleMenu();
    return;
  }

  // If menu open, ignore movement/states except gear keys
  if(menuOpen) {
    // allow gear changes
    /*
	if (e.key >= '1' && e.key <= '5') {
      currentGear = parseInt(e.key, 10);
      MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
      ACCEL = SPEED_GEARS[currentGear].accel;
      console.log('Gang gewechselt:', currentGear, '-> Speed:', MAX_FORWARD_SPEED, 'Accel:', ACCEL);
    }
	*/
	
	if (e.key >= '1' && e.key <= '9') {
  currentGear = Math.min(9, Math.max(1, parseInt(e.key, 10)));
  MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
  ACCEL = SPEED_GEARS[currentGear].accel;
  console.log('Gang gewechselt:', currentGear, '-> Speed:', MAX_FORWARD_SPEED, 'Accel:', ACCEL);
  updateControlsHelpGear();
}
    // otherwise suppress movement keys
    return;
  }

  // normal game controls
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
    e.preventDefault();
    e.stopPropagation();
    keys[e.key] = true;
  }
  else if (e.key >= '1' && e.key <= '9') {
  currentGear = Math.min(9, Math.max(1, parseInt(e.key, 10)));
  MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
  ACCEL = SPEED_GEARS[currentGear].accel;
   updateControlsHelpGear();
  console.log('Gang gewechselt:', currentGear, '-> Speed:', MAX_FORWARD_SPEED, 'Accel:', ACCEL);
}

else if (e.key && e.key.toLowerCase() === 'f') {
  e.preventDefault();
  // FULLSCREEN: helper + wiring
function isFullscreenFor(el) {
  // returns true if document is fullscreen on the requested element or any element
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}

async function enterFullscreen(el) {
  if (!el) return;
  try {
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    else if (el.mozRequestFullScreen) await el.mozRequestFullScreen();
    else if (el.msRequestFullscreen) await el.msRequestFullscreen();
  } catch (e) { /* some browsers block without gesture; ignore */ }
}

async function exitFullscreen() {
  try {
    if (document.exitFullscreen) await document.exitFullscreen();
    else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
    else if (document.mozCancelFullScreen) await document.mozCancelFullScreen();
    else if (document.msExitFullscreen) await document.msExitFullscreen();
  } catch (e) {}
}

function toggleFullscreenTarget(targetEl = mapDiv) {
  if (isFullscreenFor()) {
    exitFullscreen();
  } else {
    enterFullscreen(targetEl);
  }
}

// Button wiring (after DOM ready)
const fsBtn = document.getElementById('fullscreenBtn');
if (fsBtn) {
  fsBtn.addEventListener('click', (ev) => {
    ev.preventDefault();
    toggleFullscreenTarget(document.documentElement);
  });
}

// update button state on fullscreen changes and resize Leaflet map
function onFullChange() {
  const active = isFullscreenFor();
  if (fsBtn) {
    fsBtn.setAttribute('aria-pressed', String(active));
    fsBtn.textContent = active ? 'Vollbild beenden' : 'Vollbild';
  }
  // allow Leaflet to reflow
  try { setTimeout(()=> map.invalidateSize(), 120); } catch(e) {}
}
document.addEventListener('fullscreenchange', onFullChange);
document.addEventListener('webkitfullscreenchange', onFullChange);
document.addEventListener('mozfullscreenchange', onFullChange);
document.addEventListener('MSFullscreenChange', onFullChange);

}

document.addEventListener('keydown', (e) => {
  const tag = (e.target && e.target.tagName) || '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
  if (e.key && e.key.toLowerCase() === 'f') {
    e.preventDefault();
    toggleFullscreenTarget(document.documentElement);
  }
}, { passive:false });


}, { passive:false });

document.addEventListener('keyup', (e)=>{ if(e.key in keys){ keys[e.key]=false; e.preventDefault(); e.stopPropagation(); } }, { passive:false });

function toggleMenu(){
  menuOpen = !menuOpen;
  menuPanel.classList.toggle('open', menuOpen);
  menuPanel.setAttribute('aria-hidden', String(!menuOpen));
  if(menuOpen){
    // blur active element to avoid accidental key repeats
    try{ (document.activeElement||document.body).blur(); }catch(e){}
    // show hint in menu
    //document.getElementById('miniStatus').textContent = 'Men√º ge√∂ffnet ‚Äî bitte in den Player klicken und Play dr√ºcken.';
  } else {
    //document.getElementById('miniStatus').textContent = 'Warte auf Interaktion‚Ä¶';
  }
}

function updateControlsHelpGear(){
  const g = document.getElementById('controlsHelpGear');
  if (g) g.textContent = currentGear;
}

updateControlsHelpGear();

/* ---------- SOUNDS (Howler optional) ---------- */
let driveSound = null;
try{ driveSound = new Howl({ src: ['assets/mp3/369718__setuniman__in-the-seventies-1o34.mp3'], loop:true, volume:0.3 }); }catch(e){ console.warn('Howler not available or file missing'); }
function startDriving(){ /*if(driveSound && !driveSound.playing()) driveSound.play(); */}
function stopDriving(){ /*if(driveSound) driveSound.stop();*/ }
function playPickupSound(){ try{ zzfx(...[,,104,.04,.02,.07,,.8,,138,,,,,,,,.85,.02]); }catch(e){} }
function playBounceSound(){ try{ zzfx(0.2,0,200,0.01,0.08,0.14,1,0,0.2,0,0.14); }catch(e){} }
function playFinishSound(){ try{ zzfx(0.5,0,440,0.001,0.12,0.35,1,0.2,0.6,0,0.2); }catch(e){} }


/* ---------- CAR ---------- */
let carPos = L.latLng(STARTPOS[0], STARTPOS[1]); let headingDeg = 0; let displayedAngle = 0; let speed = 0;

/* ---------- MAIN LOOP (optimized) ---------- */
let lastTime = null; let pickupAccumulator = 0; const PICKUP_CHECK_INTERVAL = 60;
function animate(t){ if(!lastTime) lastTime = t; const dt = Math.min(0.05, (t-lastTime)/1000); lastTime = t;

  // If menuOpen we still animate but we ignore movement keys (already handled in keydown)
  if(keys.ArrowLeft) headingDeg = (headingDeg - 60 * dt + 360) % 360; if(keys.ArrowRight) headingDeg = (headingDeg + 60 * dt) % 360;
  if(keys.ArrowUp) speed += ACCEL * dt; else if(keys.ArrowDown) speed -= ACCEL * dt; else { if(speed>0) speed = Math.max(0, speed - 2.0 * dt); if(speed<0) speed = Math.min(0, speed + 2.0 * dt); }
  speed = Math.min(MAX_FORWARD_SPEED, speed); speed = Math.max(-MAX_FORWARD_SPEED*0.45, speed);

  if(Math.abs(speed) > 0.05) startDriving(); else stopDriving();

  if(Math.abs(speed) > 0.0001){
    const moveMeters = Math.abs(speed) * dt;
    const bearing = speed > 0 ? headingDeg : (headingDeg + 180) % 360;
    const candidate = destinationPoint(carPos.lat, carPos.lng, moveMeters, bearing);

    let inOn=false, inNear=false, inBorder=false;
    if(roadPixelSegments.length>0){ outer: for(let ri=0; ri<roadPixelSegments.length; ri++){ const segs = roadPixelSegments[ri]; for(let si=0; si<segs.length; si++){ const d = L.LineUtil.pointToSegmentDistance(map.latLngToLayerPoint(candidate), segs[si].a, segs[si].b); if(d <= 12){ inOn=true; break outer; } if(d <= 20) inNear=true; if(d <= 28) inBorder=true; } } }

    if(inOn){ carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.96; }
    else if(inNear){ carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.82; }
    else if(inBorder){ carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.72; }
    else { const backDistance = Math.max(1.0, moveMeters * 1.0); const backPos = destinationPoint(carPos.lat, carPos.lng, backDistance, (bearing + 180) % 360); carPos = backPos; map.setView(carPos, map.getZoom(), { animate:false }); const bounceSpeed = Math.max(2.0, Math.abs(speed) * 0.52); speed = -bounceSpeed; carDiv.classList.add('bounce'); setTimeout(()=>carDiv.classList.remove('bounce'), 180); playBounceSound(); }

    pickupAccumulator += dt*1000;
    if(pickupAccumulator >= PICKUP_CHECK_INTERVAL){ pickupAccumulator = 0;
      const centerPt = map.latLngToContainerPoint(carPos);
      const pixelTarget = L.point(centerPt.x + PICKUP_PIXEL_DIST, centerPt.y);
      const latlngTarget = map.containerPointToLatLng(pixelTarget);
      const pickupRadiusMeters = map.distance(carPos, latlngTarget);
      for(let i = stars.length -1; i>=0; i--){ const s = stars[i]; if(!s) continue; const d = map.distance(carPos, s.latlng); if(d <= pickupRadiusMeters){ if(map.hasLayer(s.marker)) map.removeLayer(s.marker); stars.splice(i,1); score += 10; updateScore(); playPickupSound(); } }
    }

    if(!finished && roads.length>0){ const lastRoadLL = flattenLatLngs(roads[0].getLatLngs()); const lastPoint = lastRoadLL[lastRoadLL.length-1]; if(lastPoint && map.distance(carPos, lastPoint) <= FINISH_DISTANCE_METERS){ finished = true; finishOverlay.style.display = 'block'; playFinishSound(); } }
  }

  if(rotWrapper){ const targetAngle = -headingDeg; const diff = shortestAngleDiff(targetAngle, displayedAngle); const step = diff * (1 - Math.exp(-8 * dt)); displayedAngle += step; if(Math.abs(shortestAngleDiff(targetAngle, displayedAngle)) < 0.02) displayedAngle = ((targetAngle%360)+360)%360; rotWrapper.style.transform = `rotate(${displayedAngle}deg)`; }

  const tiltMax = 12; let angularVelocity = 0; if(keys.ArrowLeft) angularVelocity = -60; if(keys.ArrowRight) angularVelocity = 60; const lean = (angularVelocity / 60) * (Math.min(Math.abs(speed)/MAX_FORWARD_SPEED,1)) * tiltMax; carDiv.style.transform = `translate(-50%,-50%) rotate(${lean}deg)`;

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ---------- fallback onRoad ---------- */
function onRoad(latlng, pixelTolerance = 12){ if(roads.length === 0) return false; const p = map.latLngToLayerPoint(latlng); for(let ri=0; ri<roads.length; ri++){ let latlngs = roads[ri].getLatLngs(); if(Array.isArray(latlngs[0]) && latlngs[0] && typeof latlngs[0].lat === 'undefined') latlngs = latlngs.flat(); for(let i=0;i<latlngs.length-1;i++){ const a = map.latLngToLayerPoint(latlngs[i]); const b = map.latLngToLayerPoint(latlngs[i+1]); if(L.LineUtil.pointToSegmentDistance(p,a,b) <= pixelTolerance) return true; } } return false; }

/* ---------- rotate wrapper ---------- */
let rotWrapper = null;
map.whenReady(()=>{ const container = map.getContainer(); const pane = container.querySelector('.leaflet-map-pane'); if(!pane) return; const wrapper = document.createElement('div'); wrapper.className = 'rotate-wrapper'; wrapper.style.position = 'absolute'; wrapper.style.inset = '0'; wrapper.style.willChange = 'transform'; container.insertBefore(wrapper, pane); wrapper.appendChild(pane); rotWrapper = wrapper; rebuildRoadPixelSegments(); alert('‚Ñπ Press SPACE for Menu.'); });

/* ---------- auto-load (optional) ---------- */
(function autoLoadGeoJSON(){ const geojsonDataUrl = 'assets/json/strecken.json'; fetch(geojsonDataUrl).then(res => { if(!res.ok) throw new Error('not found'); return res.json(); }).then(j => { if(!j || j.type !== 'FeatureCollection') return; clearRoads(); clearStars(); score=0; updateScore(); finished=false; finishOverlay.style.display='none'; let added=0; j.features.forEach(fe=>{ if(!fe.geometry) return; const g=fe.geometry; if(g.type==='LineString'){ addRoadFromCoords(g.coordinates); added++; } else if(g.type==='MultiLineString'){ g.coordinates.forEach(line=> addRoadFromCoords(line)); added++; } }); if(added===0) return; placeStarsAll(STAR_SPACING); rebuildRoadPixelSegments(); if(roads.length>0){ const latlngs = flattenLatLngs(roads[0].getLatLngs()); const start = latlngs[0]; if(start){ carPos = start; map.setView(carPos, MAP_ZOOM, {animate:false}); speed=0; headingDeg=180; displayedAngle=-headingDeg; if(rotWrapper) rotWrapper.style.transform=`rotate(${displayedAngle}deg)`; } } loaderEl.style.display='none'; console.log('Auto-GeoJSON geladen: ' + added + ' Feature(s)'); }).catch(()=>{}); })();

/* ============================
   Musik-Menu (kapsel, keine globalen Konflikte)
   - Space toggled (siehe oben).
   - Resume / save position / M toggle works like in original musik.js,
     aber lokal scoped.
   ============================ */

(function MusicMenuModule(){
  const mixIframe = document.getElementById('mixcloudPlayer');
  const iframeOverlay = document.getElementById('iframeOverlay');
  const overlayText = document.getElementById('overlayText');
  const miniStatus = document.getElementById('miniStatus');

  let widget = null;
  let widgetReady = false;
  let userInteracted = false;
  let isPlaying = false;
  let pendingSeekSeconds = null;
  let _saveInterval = null;

  const STORAGE_KEY = 'mixcloud_pos_' + encodeURIComponent(mixIframe.src);

  // init widget safely
  try{
    widget = Mixcloud.PlayerWidget(mixIframe);
    widget.ready.then(()=>{
      widgetReady = true;
      try{
        widget.events.play.on(()=>{ isPlaying = true; confirmPlay('widget.events.play'); console.log("playing.."); });
        widget.events.pause.on(()=>{ isPlaying = false; });
		widget.events.seek.on(() => {
		console.log("seeking...");
      // small delay so widget finished internal updates, then reclaim focus
      setTimeout(() => returnFocusToMap(), 60);
    });
        widget.events.ended.on(()=>{ localStorage.removeItem(STORAGE_KEY); //miniStatus.textContent = 'Track beendet ‚Äî gespeicherte Position gel√∂scht';
		});
      }catch(e){ console.warn('events unavailable', e); }

      // load saved pos (pending)
      const savedRaw = localStorage.getItem(STORAGE_KEY);
      const saved = savedRaw ? parseFloat(savedRaw) : 0;
      if (saved && !Number.isNaN(saved) && saved > 0){ pendingSeekSeconds = saved; console.log('pending saved pos', pendingSeekSeconds); }

      // start periodic saving
      startSavingPositionEverySecond();
    }).catch(err=>console.warn('widget.ready rejected', err));
  }catch(e){ console.warn('widget init failed', e); }

  // Detect clicks in iframe area: capture-phase pointerdown/touchstart global, check coords against iframe rect
  function onGlobalPointerDown(e){
    const tag = (e.target && e.target.tagName) || '';
    if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
    const rect = mixIframe.getBoundingClientRect();
    const x = (typeof e.clientX === 'number') ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
    const y = (typeof e.clientY === 'number') ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
    if (typeof x !== 'number' || typeof y !== 'number') return;
    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom){
      startPlayDetection('pointerdown-in-iframe');
    }
  }
  document.addEventListener('pointerdown', onGlobalPointerDown, true);
  document.addEventListener('touchstart', onGlobalPointerDown, true);

  try{ mixIframe.addEventListener('focus', ()=>{ startPlayDetection('iframe-focus'); }); }catch(e){}
  window.addEventListener('blur', ()=>{ startPlayDetection('window-blur'); });

  const PLAY_POLL_INTERVAL = 350; const PLAY_DETECT_TIMEOUT = 15000;
  let _playDetectPoll = null; let _playDetectTimer = null; let _widgetPlayHandler = null;

  function startPlayDetection(source){
    if (_playDetectPoll) return;
    //miniStatus.textContent = 'Erkenne Play (trigger: ' + source + ')';
    try{ if (widget && widget.events && widget.events.play && !_widgetPlayHandler){ _widgetPlayHandler = ()=> confirmPlay('widget.events.play'); widget.events.play.on(_widgetPlayHandler); } }catch(e){}
    const start = Date.now();
    _playDetectPoll = setInterval(async ()=>{
      if (!widgetReady) return;
      try{
        const pos = await widget.getPosition();
        if (typeof pos === 'number' && isFinite(pos) && pos > 0.5){ confirmPlay('getPosition>0.5s (poll)'); }
      }catch(err){}
      if (Date.now() - start > PLAY_DETECT_TIMEOUT){ stopPlayDetection(); //miniStatus.textContent = 'Kein Play erkannt (timeout)';
	  }
    }, PLAY_POLL_INTERVAL);
    _playDetectTimer = setTimeout(()=>stopPlayDetection(), PLAY_DETECT_TIMEOUT);
	
  }
  function stopPlayDetection(){ if (_playDetectPoll){ clearInterval(_playDetectPoll); _playDetectPoll = null; } if (_playDetectTimer){ clearTimeout(_playDetectTimer); _playDetectTimer = null; } }

  async function confirmPlay(detectedVia){
  
  
  if(menuOpen){
	//console.log("play confirmed.");
	setTimeout(() => returnFocusToMap(), 60);
  }
  
  
    if (userInteracted) return;
    userInteracted = true; isPlaying = true;
    overlayText.textContent = 'Play gedr√ºckt. Mit der Taste M kannst du nun die Musik an und aus machen.';
    //miniStatus.textContent = 'Play gedr√ºckt (detected via: ' + detectedVia + ')';
	returnFocusToMap();
	
	// minimaler, robuster Ablauf (nur als Snippet)
// neu: robuster helper-Aufruf
returnFocusToMap();
// optional: Men√º schlie√üen, wenn du das m√∂chtest
menuPanel.classList.remove('open'); menuOpen = false;
	
    await tryPendingSeekAfterUserInteracted();
    stopPlayDetection();
  }

  async function attemptSeek(seconds) {
  console.log("trying focus...");
  if (!widgetReady || !widget || typeof widget.seek !== 'function') return false;
  try {
    const res = await widget.seek(seconds);
    // Mixcloud gibt manchmal `false` bei Fehlern zur√ºck ‚Äî alles andere behandeln wir als Erfolg
    if (res === false) return false;

    // Seek erfolgreich: gespeicherte Position zur√ºcksetzen
    pendingSeekSeconds = null;

    // Fokus zur√ºck zur Map holen (robustes Helper mit Retries)
    try { returnFocusToMap(); } catch (e) { /* ignore */ }

    return true;
  } catch (err) {
    console.warn('widget.seek failed', err);
    return false;
  }
}

  async function tryPendingSeekAfterUserInteracted(){ if (!widgetReady) return; if (!pendingSeekSeconds) return; const ok = await attemptSeek(pendingSeekSeconds); if (ok) return; const start = Date.now(); const timeout = 10000; const poll = setInterval(async ()=>{ if (!widgetReady) return; try{ const pos = await widget.getPosition(); if (typeof pos === 'number' && isFinite(pos) && pos > 0.1){ const ok2 = await attemptSeek(pendingSeekSeconds); if (ok2){ clearInterval(poll); } } }catch(e){} if (Date.now()-start > timeout){ clearInterval(poll); } }, 600); }

  function startSavingPositionEverySecond(){ if (_saveInterval) return; _saveInterval = setInterval(async ()=>{ if (!widgetReady) return; try{ const pos = await widget.getPosition(); if (typeof pos === 'number' && isFinite(pos)){ localStorage.setItem(STORAGE_KEY, String(Math.floor(pos))); } }catch(e){} }, 1000); }
  function stopSavingPosition(){ if (_saveInterval){ clearInterval(_saveInterval); _saveInterval = null; } }

  async function togglePlayPauseMusic(){ if (!widgetReady) return; if (!userInteracted){ alert('Bitte zuerst Play im Player dr√ºcken.'); return; } try{ if (typeof widget.togglePlay === 'function'){ await widget.togglePlay(); return; } if (isPlaying) await widget.pause(); else await widget.play(); }catch(err){} }

  // expose M toggle and menu-key globally by listening for keydown on document
  document.addEventListener('keydown', (e)=>{
    const tag = (e.target && e.target.tagName) || '';
    if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
    if (e.key && e.key.toLowerCase() === 'm'){
      e.preventDefault();
      togglePlayPauseMusic();
    }
  }, {passive:false});

  // load pending saved pos from storage immediately (but don't seek until user interacts)
  try{ const savedRaw = localStorage.getItem(STORAGE_KEY); const saved = savedRaw ? parseFloat(savedRaw) : 0; if (saved && !Number.isNaN(saved) && saved > 0){ pendingSeekSeconds = saved; console.log('pending saved pos', pendingSeekSeconds); } }catch(e){}
  
  
  // A: Helper ‚Äî INSIDE MusicMenuModule so mixIframe and map are in scope
// state var (MusicMenuModule scope)
let _restorePointerHandler = null;

function enableIframePointerEvents() {
  try { mixIframe.style.pointerEvents = ''; } catch(e) {}
  if (_restorePointerHandler) {
    document.removeEventListener('pointerdown', _restorePointerHandler, true);
    _restorePointerHandler = null;
  }
}

// robustes returnFocusToMap: kurz deaktivieren, dann re-enable on next pointerdown OR timeout
function returnFocusToMap(attempts = 8, interval = 80) {
  try { mixIframe.blur(); } catch(e){}
  const cont = map.getContainer();
  if (typeof cont.tabIndex === 'undefined' || cont.tabIndex < 0) cont.tabIndex = 0;
  let tries = 0;
  const id = setInterval(()=> {
    try { cont.focus(); } catch(e) {}
    tries++; if (tries >= attempts) clearInterval(id);
  }, interval);
}


  // cleanup on unload
  window.addEventListener('beforeunload', ()=>{ stopSavingPosition(); });
  
  
  
})(); // end MusicMenuModule

// FULLSCREEN: helper + wiring
function isFullscreenFor(el) {
  // returns true if document is fullscreen on the requested element or any element
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}

async function enterFullscreen(el) {
  if (!el) return;
  try {
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    else if (el.mozRequestFullScreen) await el.mozRequestFullScreen();
    else if (el.msRequestFullscreen) await el.msRequestFullscreen();
  } catch (e) { /* some browsers block without gesture; ignore */ }
}

async function exitFullscreen() {
  try {
    if (document.exitFullscreen) await document.exitFullscreen();
    else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
    else if (document.mozCancelFullScreen) await document.mozCancelFullScreen();
    else if (document.msExitFullscreen) await document.msExitFullscreen();
  } catch (e) {}
}

function toggleFullscreenTarget(targetEl = mapDiv) {
  if (isFullscreenFor()) {
    exitFullscreen();
  } else {
    enterFullscreen(targetEl);
  }
}

// Button wiring (after DOM ready)
const fsBtn = document.getElementById('fullscreenBtn');
if (fsBtn) {
  fsBtn.addEventListener('click', (ev) => {
    ev.preventDefault();
    toggleFullscreenTarget(document.documentElement); // vollbild f√ºr die Karte
  });
}

// update button state on fullscreen changes and resize Leaflet map
function onFullChange() {
  const active = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
  if (fsBtn) {
    fsBtn.setAttribute('aria-pressed', String(active));
    fsBtn.textContent = active ? 'Vollbild beenden' : 'Vollbild';
  }
  // Leaflet neu rechnen
  try { setTimeout(()=> map.invalidateSize(), 120); } catch(e){}
}

document.addEventListener('fullscreenchange', onFullChange);
document.addEventListener('webkitfullscreenchange', onFullChange);
document.addEventListener('mozfullscreenchange', onFullChange);
document.addEventListener('MSFullscreenChange', onFullChange);








</script>
</body>
</html>
