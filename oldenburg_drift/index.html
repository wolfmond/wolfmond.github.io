<!doctype html>
<!-- 

All rights reserved. At least at this very moment; I'm planning to realease this game into the Creative Commons, but please let me finish it first. It's still super buggy and I have a lot of Ideas. It's playable, yet; but don't expect too much. This is merely a draft, yet. Greetz, Wolfmond

Current Version: 2025-09-22_17.56

-->
<html lang="de">
<head>
<meta charset="utf-8"/>
<title>Oldenburg Kart ‚Äî Perfekt (stars + sounds + fixed zoom)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<script>

const message = "‚ö†Ô∏è This is a highly experimental Prototype. Not yet intended for public use. All Rights Reserved. No Warranties. Use this software at your own risk. This website can be played with arrow keys on your keyboard on a Laptop/PC. Tested with Chrome & Brave. Runs best & smooth in Chrome. Background Driving Music: In the seventies 1O34 by Setuniman -- https://freesound.org/s/369718/ -- License: Attribution NonCommercial 4.0";

// Zeigt eine Best√§tigungsbox an
if (!confirm(message)) {
  // Wenn der Nutzer auf "Abbrechen" klickt
  window.location.href = "about:blank";
}


</script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  html,body,#map { height:100%; margin:0; padding:0; font-family: system-ui, Arial, sans-serif; }
  #map { position:relative; overflow:hidden; background:#e7eef8; }
  
  .star-icon {
    width: 24px;
    height: 24px;
    background: none;
    pointer-events: none;
    animation: pulse 1.5s infinite;
    background-color: rgba(0,0,0,0.5);
    padding: 2px;
    border-radius: 50%;
  }
  .star-icon svg polygon {
    fill: #ffd83d;
    stroke: #ffdc4d;
    stroke-width: 1;
  }
  @keyframes pulse {
    0%, 100% {
      transform: scale(1);
      opacity: 1;
    }
    50% {
      transform: scale(1.4);
      opacity: 0.6;
    }
  }

  .rotate-wrapper { position:absolute; inset:0; transform-origin:50% 50%; will-change:transform; }

  .car-center {
    position: absolute; z-index: 12000; left: 50%; top: 50%;
    transform: translate(-50%, -50%); width: 36px; height: 36px; border-radius: 50%;
    background: linear-gradient(180deg,#4aa3ff,#2b6fd6);
    box-shadow: 0 6px 14px rgba(0,0,0,0.35); border: 3px solid white; pointer-events: none;
    display:flex; align-items:center; justify-content:center;
    transition: box-shadow 120ms linear, transform 120ms linear;
  }
  .car-center.bounce { box-shadow: 0 4px 12px rgba(0,0,0,0.55); transform: translate(-50%,-48%); }

  .car-arrow { width:0;height:0; border-left:8px solid transparent; border-right:8px solid transparent; border-bottom:14px solid rgba(255,255,255,0.95); }

  .score { position: absolute; top: 12px; right: 12px; z-index: 14000; background: rgba(255,255,255,0.95); padding: 8px 12px; border-radius: 8px; font-weight:700; display:flex; gap:12px; align-items:center; box-shadow: 0 6px 18px rgba(0,0,0,0.08); }
  .loader { position: absolute; top: 12px; left: 12px; z-index: 14000; background: rgba(255,255,255,0.96); padding: 10px; border-radius: 8px; font-size:13px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); min-width:220px; }
  .touch-controls { position: absolute; bottom: 12px; left: 12px; z-index: 14000; display:flex; gap:8px; display:none;}
  .btn { background: rgba(255,255,255,0.95); border-radius:10px; padding:8px 12px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); font-weight:700; user-select:none; touch-action: none; }
  @media (max-width:600px){ .loader { left:8px; right:8px; min-width:auto; font-size:12px; padding:8px; } .score { right:8px; top:8px; padding:6px 8px; } .car-center { width:32px; height:32px; border-width:2px; } }
  .finish-overlay { position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:16000; background: rgba(255,255,255,0.96); padding:18px 22px; border-radius:12px; box-shadow: 0 10px 30px rgba(0,0,0,0.12); display:none; font-weight:800; }
  /* tile color rotation uses CSS variable --map-hue */
  .leaflet-tile { filter: hue-rotate(var(--map-hue, 0deg)) saturate(0.3) contrast(1.03) brightness(1.02) invert(1); }
  
  #overlayed {
  position: absolute;  /* √úber der Karte */
  top: 0;
  left: 0;
  height: 100vh;       /* Ganze H√∂he */
  width: 100vw;        /* Ganze Breite */
  z-index: 1000;       /* √úber der Leaflet-Karte (Leaflet nutzt ~z-index: 400-600) */
  pointer-events: none; /* Optional: Overlay ignoriert Mausklicks, Karte bleibt interaktiv */
}
</style>
</head>
<body>
<div id="map"></div>
<div class="car-center" id="carDiv" title="Dein Wagen"><div class="car-arrow" id="carArrow"></div></div>

<div class="loader" id="loader">
  <div style="font-weight:700">Oldenburg Kart ‚Äî Perfect</div>
  <div class="small">Lade ein GeoJSON (FeatureCollection mit LineString). Sterne-Abstand: <strong>100 m</strong>.</div>
  <input id="geoFile" type="file" accept="application/json,application/geo+json" />
  <div style="margin-top:8px" class="row"><button id="centerBtn" style="min-width:80px">Zentrieren</button> <button id="resetBtn" style="min-width:80px">Reset</button></div>
</div>

<div class="score"><div>Score: <span class="value" id="score">0</span></div><div class="hs" id="hs">Highscore: 0</div></div>

<div class="touch-controls" id="touchControls" aria-hidden="true">
  <div class="btn" id="tLeft">‚óÄ</div>
  <div style="display:flex;flex-direction:column;gap:8px">
    <div class="btn" id="tUp">‚ñ≤</div>
    <div class="btn" id="tDown">‚ñº</div>
  </div>
  <div class="btn" id="tRight">‚ñ∂</div>
</div>

<div class="finish-overlay" id="finishOverlay">Strecke beendet üéâ</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/zzfx@1.3.2/ZzFXMicro.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

<script>

// ---------------- CONFIG ----------------
document.addEventListener('click', ()=>{ console.log('click -> try zzfx'); try{ zzfx(0.12,0,440,0.01,0.12,0.2,1,0,0,0,0); }catch(e){ console.error(e); } }, {once:true});

const MAP_ZOOM = 19;
const MAP_HUE_ROTATION = 90; // konstante f√ºr color-rotation der tiles; kannst du anpassen
document.documentElement.style.setProperty('--map-hue', MAP_HUE_ROTATION + 'deg');
document.documentElement.style.setProperty('--map-hue', MAP_HUE_ROTATION + 'deg');

const STAR_SPACING = 10;
const CAR_SPEED = 30.0;
const ROTATION_SPEED = 50;
const FRICTION = 2.0; // siehe Erkl√§rung oben
const MAX_REVERSE_SPEED = - (CAR_SPEED * 0.45);
const STARTPOS = [53.143559, 8.22416]

const Z_ON = 12, Z_NEAR = 20, Z_BORDER = 28;
const PICKUP_PIXEL_DIST = 14;
const FINISH_DISTANCE_METERS = 8;

const BOUNCE_FACTOR = 0.52;
const MIN_BOUNCE_SPEED = 2.0;

const SPEED_GEARS = {
1: { speed: 15, accel: 10 },
2: { speed: 25, accel: 15 },
3: { speed: 35, accel: 20 },
4: { speed: 45, accel: 25 },
5: { speed: 60, accel: 30 }
};
let currentGear = 1; // Start-Gang


// Diese beiden Konstanten durch Variablen ersetzen:
let MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
let ACCEL = SPEED_GEARS[currentGear].accel;

// Motorenger√§usch (loop)
const driveSound = new Howl({
  src: ['assets/mp3/369718__setuniman__in-the-seventies-1o34.mp3'],
  loop: true,
  volume: 0.3
});

/*
// Sterne-Sound (einmal)
const pickupSound = new Howl({
  //src: ['pickup.wav'],
  src: ['pickup.wav'],
  volume: 0.7
});
*/

// ---------------- MAP (fixed zoom) ----------------
const map = L.map('map', {
  keyboard: false,
  zoomControl: false,
  minZoom: MAP_ZOOM,
  maxZoom: MAP_ZOOM,
  scrollWheelZoom: false,
  doubleClickZoom: false,
  touchZoom: false,
  boxZoom: false,
  dragging: false,
}).setView(STARTPOS, MAP_ZOOM);

L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { minZoom: MAP_ZOOM, maxZoom: MAP_ZOOM, keepBuffer: 2, attribution: '<a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noreferrer">¬© OpenStreetMap contributors</a>' }).addTo(map);

// Starten, wenn Auto f√§hrt
function startDriving() {
  if (!driveSound.playing()) driveSound.play();
}

// Stoppen, wenn Auto steht
function stopDriving() {
  driveSound.stop();
}

// Sterne sammeln
function collectStar() {
  pickupSound.play();
}

// rotate wrapper
let rotWrapper = null;
map.whenReady(() => {
  const container = map.getContainer();
  const pane = container.querySelector('.leaflet-map-pane');
  if(!pane) return;
  const wrapper = document.createElement('div'); wrapper.className = 'rotate-wrapper';
  container.insertBefore(wrapper, pane); wrapper.appendChild(pane); rotWrapper = wrapper;
});

// ---------------- DOM ----------------
const carDiv = document.getElementById('carDiv');
const scoreEl = document.getElementById('score');
const hsEl = document.getElementById('hs');
const geoFileEl = document.getElementById('geoFile');
const loaderEl = document.getElementById('loader');
const centerBtn = document.getElementById('centerBtn');
const resetBtn = document.getElementById('resetBtn');
const finishOverlay = document.getElementById('finishOverlay');

// ---------------- STATE ----------------
let roads = [], stars = [], score = 0, finished = false;
hsEl.textContent = 'Highscore: ' + (localStorage.getItem('oldenburg_kart_highscore_custom') || 0);
function updateScore(){ scoreEl.textContent = score; const prev = Number(localStorage.getItem('oldenburg_kart_highscore_custom')||0); if(score>prev){ localStorage.setItem('oldenburg_kart_highscore_custom', score); hsEl.textContent = 'Highscore: ' + score; } }

// ---------------- CAR ----------------
let carPos = L.latLng(STARTPOS[0],STARTPOS[1]);
let headingDeg = 0;
let displayedAngle = 0;
let speed = 0;

// ---------------- HELPERS ----------------
const R = 6378137;
function toRad(d){ return d * Math.PI / 180; }
function toDeg(r){ return r * 180 / Math.PI; }
function destinationPoint(lat, lon, distanceMeters, bearingDeg){
  const Œ¥ = distanceMeters / R; const Œ∏ = toRad(bearingDeg);
  const œÜ1 = toRad(lat); const Œª1 = toRad(lon);
  const sinœÜ1 = Math.sin(œÜ1), cosœÜ1 = Math.cos(œÜ1);
  const sinŒ¥ = Math.sin(Œ¥), cosŒ¥ = Math.cos(Œ¥);
  const œÜ2 = Math.asin(sinœÜ1 * cosŒ¥ + cosœÜ1 * sinŒ¥ * Math.cos(Œ∏));
  const Œª2 = Œª1 + Math.atan2(Math.sin(Œ∏) * sinŒ¥ * cosœÜ1, cosŒ¥ - sinœÜ1 * Math.sin(œÜ2));
  return L.latLng(toDeg(œÜ2), toDeg(Œª2));
}
function shortestAngleDiff(target, current){ target = ((target%360)+360)%360; current = ((current%360)+360)%360; return (target - current + 540) % 360 - 180; }
function flattenLatLngs(latlngs){ if(!Array.isArray(latlngs)) return []; if(latlngs.length>0 && Array.isArray(latlngs[0]) && typeof latlngs[0].lat === 'undefined') return latlngs.flat(); return latlngs; }

// ---------------- ROADS & STARS ----------------
function clearRoads(){ roads.forEach(r=>{ if(map.hasLayer(r)) map.removeLayer(r); }); roads=[]; roadPixelSegments=[]; }
function clearStars(){ stars.forEach(s=>{ if(map.hasLayer(s)) map.removeLayer(s); }); stars=[]; }

function addRoadFromCoords(coords, style){
  const latlngs = coords.map(c => L.latLng(c[1], c[0]));
  const pl = L.polyline(latlngs, style || { color:'#2b6fd6', weight:4, opacity:0.95 }).addTo(map);
  roads.push(pl); return pl;
}

// create star divIcon exactly matching your css
function createStarIcon(){
  return L.divIcon({
    className: '',
    html: `<div class="star-icon">
             <svg viewBox="0 0 100 100" width="100%" height="100%"><polygon points="50,5 61,39 98,39 68,59 79,91 50,70 21,91 32,59 2,39 39,39"/></svg>
           </div>`,
    iconSize: [24,24],
    iconAnchor: [12,12]
  });
}

function placeStarsAll(spacingMeters){
  clearStars();
  for(let ri=0; ri<roads.length; ri++){
    const latlngs = flattenLatLngs(roads[ri].getLatLngs());
    const samples = samplePointsAlongPath(latlngs, spacingMeters);
    const pts = samples.length ? samples : latlngs;
    pts.forEach(p=>{
      const m = L.marker(p, { icon: createStarIcon(), interactive:false }).addTo(map);
      stars.push(m);
    });
  }
}

function samplePointsAlongPath(latlngs, spacingMeters){
  const out=[]; if(!latlngs||latlngs.length<2) return out;
  let traveled=0, nextTarget=spacingMeters;
  for(let i=0;i<latlngs.length-1;i++){
    const a=latlngs[i], b=latlngs[i+1]; const segLen = map.distance(a,b);
    while(nextTarget <= traveled + segLen){
      const t=(nextTarget - traveled)/segLen;
      out.push(L.latLng(a.lat + (b.lat-a.lat)*t, a.lng + (b.lng-a.lng)*t));
      nextTarget += spacingMeters;
    }
    traveled += segLen;
  }
  return out;
}

// ---------------- PIXEL-Segment-Cache ----------------
//let roadPixelSegments = [];
function rebuildRoadPixelSegments(){
  roadPixelSegments = [];
  for(let ri=0; ri<roads.length; ri++){
    const latlngs = flattenLatLngs(roads[ri].getLatLngs());
    const segs = [];
    for(let i=0;i<latlngs.length-1;i++){
      const a = map.latLngToLayerPoint(latlngs[i]);
      const b = map.latLngToLayerPoint(latlngs[i+1]);
      segs.push({a,b});
    }
    roadPixelSegments.push(segs);
  }
}
map.on('zoomend movestart moveend resize', ()=>{ rebuildRoadPixelSegments(); });

// ---------------- GEOJSON LOADER ----------------
geoFileEl.addEventListener('change', (ev)=>{ const f = ev.target.files && ev.target.files[0]; if(!f) return; const reader = new FileReader(); reader.onload = (e)=>{ try{ const j = JSON.parse(e.target.result); if(!j || j.type !== 'FeatureCollection'){ alert('Bitte eine FeatureCollection (GeoJSON) ausw√§hlen.'); return; } clearRoads(); clearStars(); score = 0; updateScore(); finished = false; finishOverlay.style.display = 'none'; let added = 0; j.features.forEach(fe=>{ if(!fe.geometry) return; const g = fe.geometry; if(g.type === 'LineString'){ addRoadFromCoords(g.coordinates); added++; } else if(g.type === 'MultiLineString'){ g.coordinates.forEach(line => addRoadFromCoords(line)); added++; } }); if(added === 0){ alert('Keine LineString-Features gefunden.'); return; } placeStarsAll(STAR_SPACING); rebuildRoadPixelSegments(); if(roads.length>0){ const latlngs = flattenLatLngs(roads[0].getLatLngs()); const start = latlngs[0]; if(start){ carPos = start; map.setView(carPos, MAP_ZOOM, {animate:false}); speed = 0; headingDeg = 0; displayedAngle = 0; if(rotWrapper) rotWrapper.style.transform = 'rotate(0deg)'; } } loaderEl.style.display = 'none'; alert('GeoJSON geladen: ' + added + ' Feature(s).'); }catch(err){ alert('Fehler beim Einlesen: ' + (err && err.message ? err.message : err)); } }; reader.readAsText(f); });

centerBtn.addEventListener('click', ()=>{ if(roads.length>0) map.fitBounds(L.featureGroup(roads).getBounds().pad(0.2)); else map.setView(STARTPOS, MAP_ZOOM); });
resetBtn.addEventListener('click', ()=>{ clearRoads(); clearStars(); score=0; updateScore(); speed=0; headingDeg=0; displayedAngle=0; if(rotWrapper) rotWrapper.style.transform='rotate(0deg)'; map.setView(STARTPOS, MAP_ZOOM); loaderEl.style.display = ''; finished=false; finishOverlay.style.display='none'; });

// ---------------- INPUT ----------------
const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
//document.addEventListener('keydown', (e)=>{ if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){ e.preventDefault(); e.stopPropagation(); keys[e.key]=true; } }, { passive:false });


document.addEventListener('keydown', (e)=>{
if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
e.preventDefault();
e.stopPropagation();
keys[e.key] = true;
}
// NEU: Gangschaltung √ºber 1‚Äì5
else if (e.key >= '1' && e.key <= '5') {
currentGear = parseInt(e.key, 10);
MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
ACCEL = SPEED_GEARS[currentGear].accel;
console.log('Gang gewechselt:', currentGear, '-> Speed:', MAX_FORWARD_SPEED, 'Accel:', ACCEL);
}
}, { passive:false });


document.addEventListener('keyup', (e)=>{ if(e.key in keys){ keys[e.key]=false; e.preventDefault(); e.stopPropagation(); } }, { passive:false });
function makeButtonHold(id, keyName){ const el = document.getElementById(id); if(!el) return; const start = (ev)=>{ try{ ev.preventDefault(); ev.stopPropagation(); }catch(e){} keys[keyName]=true; }; const stop = (ev)=>{ keys[keyName]=false; }; el.addEventListener('touchstart', start, { passive:false }); el.addEventListener('touchend', stop); el.addEventListener('touchcancel', stop); el.addEventListener('mousedown', (e)=>{ e.preventDefault(); start(e); }); el.addEventListener('mouseup', stop); el.addEventListener('mouseleave', stop); }
makeButtonHold('tLeft','ArrowLeft'); makeButtonHold('tRight','ArrowRight'); makeButtonHold('tUp','ArrowUp'); makeButtonHold('tDown','ArrowDown');



document.addEventListener('keydown', (e) => {
if (e.key >= '1' && e.key <= '5') {
currentGear = parseInt(e.key, 10);
MAX_FORWARD_SPEED = SPEED_GEARS[currentGear].speed;
ACCEL = SPEED_GEARS[currentGear].accel;
console.log('Gang gewechselt: ', currentGear, '-> Speed:', MAX_FORWARD_SPEED, 'Accel:', ACCEL);
}
});

// ---------------- SOUNDS ----------------
// pickup sound exactly as provided
function playPickupSound(){ try{ zzfx(...[,,104,.04,.02,.07,,.8,,138,,,,,,,,.85,.02]); }catch(e){} }

// looped driving sound while moving (uses your zzfx "Music 53" params)
let driveLoopId = null;
const DRIVE_LOOP_INTERVAL = 280; // ms between repeats; tweakable
//const DRIVE_LOOP_PARAMS = [2.5,0,65.40639,.13,.23,.42,1,2.4,,,,,,.1,,.1,.04,.82,.17,,303];
//const DRIVE_LOOP_PARAMS = [0.1,.01,120,,1,0,3,,-3,1,,,.03,,,,,.61,,.36];
//const DRIVE_LOOP_PARAMS = [2,,16,.17,.09,.07,5,.5,,,,,,,,,,.85,.02,,1];
//const DRIVE_LOOP_PARAMS = [0.3,0,90,.05,.2,.2,3,1,0,0,0,0,0,0,0,0,0.9,0,0];

//const DRIVE_LOOP_PARAMS = [.4,0,253,.03,.36,.001,5,.7921240274692839,-77,,4,.25,,,74,.3,,.98,.44,,-1278];
//const DRIVE_LOOP_PARAMS = [.1,0,253,,1,0,1,.7921240274692839,-77,,4,.25,,,74,.3,,.98,,,-1278];
const DRIVE_LOOP_PARAMS = [.6,,466,,.05,.06,4,.9,12,,3,,.04,.6,139,,,.63,.06,.39,-1031];



function startDriveLoop(){
  if(driveLoopId) return;
  // play immediately and then start repeating
  try{ zzfx(...DRIVE_LOOP_PARAMS); }catch(e){}
  driveLoopId = setInterval(()=>{ try{ zzfx(...DRIVE_LOOP_PARAMS); }catch(e){} }, DRIVE_LOOP_INTERVAL);
}
function stopDriveLoop(){ if(driveLoopId){ clearInterval(driveLoopId); driveLoopId = null; } }

// small one-off sounds
function playBounceSound(){ try{ zzfx(0.2,0,200,0.01,0.08,0.14,1,0,0.2,0,0.14); }catch(e){} }
function playFinishSound(){ try{ zzfx(0.5,0,440,0.001,0.12,0.35,1,0.2,0.6,0,0.2); }catch(e){} }

// ---------------- PIXEL CACHE & helpers ----------------
let roadPixelSegments = [];
function rebuildRoadPixelSegments(){
  roadPixelSegments = [];
  for(let ri=0; ri<roads.length; ri++){
    const latlngs = flattenLatLngs(roads[ri].getLatLngs());
    const segs = [];
    for(let i=0;i<latlngs.length-1;i++){
      const a = map.latLngToLayerPoint(latlngs[i]);
      const b = map.latLngToLayerPoint(latlngs[i+1]);
      segs.push({a,b});
    }
    roadPixelSegments.push(segs);
  }
}

// ---------------- MAIN LOOP ----------------
let lastTime = null;
function animate(t){
  if(!lastTime) lastTime = t;
  const dt = Math.min(0.05, (t-lastTime)/1000);
  lastTime = t;

  if(keys.ArrowLeft) headingDeg = (headingDeg - ROTATION_SPEED * dt + 360) % 360;
  if(keys.ArrowRight) headingDeg = (headingDeg + ROTATION_SPEED * dt) % 360;

  if(keys.ArrowUp) speed += ACCEL * dt;
  else if(keys.ArrowDown) speed -= ACCEL * dt;
  else { if(speed > 0) speed = Math.max(0, speed - FRICTION * dt); if(speed < 0) speed = Math.min(0, speed + FRICTION * dt); }

  speed = Math.min(MAX_FORWARD_SPEED, speed); speed = Math.max(MAX_REVERSE_SPEED, speed);

  // manage drive loop: start when speed sufficiently positive, stop when nearly zero
  //if(Math.abs(speed) > 0.6) startDriveLoop(); else stopDriveLoop();
  
  if(Math.abs(speed) > 0.01){
    if(!driveSound.playing()) driveSound.play();
}else{
    driveSound.stop();
}
  

  if(Math.abs(speed) > 0.0001){
    const moveMeters = Math.abs(speed) * dt;
    const bearing = speed > 0 ? headingDeg : (headingDeg + 180) % 360;
    const candidate = destinationPoint(carPos.lat, carPos.lng, moveMeters, bearing);

    const candidatePoint = map.latLngToLayerPoint(candidate);
    let inOn=false, inNear=false, inBorder=false;
    if(roadPixelSegments.length > 0){
      outer: for(let ri=0; ri<roadPixelSegments.length; ri++){
        const segs = roadPixelSegments[ri];
        for(let si=0; si<segs.length; si++){
          const d = L.LineUtil.pointToSegmentDistance(candidatePoint, segs[si].a, segs[si].b);
          if(d <= Z_ON){ inOn = true; break outer; }
          if(d <= Z_NEAR) inNear = true;
          if(d <= Z_BORDER) inBorder = true;
        }
      }
    } else {
      inOn = onRoad(candidate, Z_ON);
      inNear = inOn || onRoad(candidate, Z_NEAR);
      inBorder = inNear || onRoad(candidate, Z_BORDER);
    }

    if(inOn){
      carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.96;
    } else if(inNear){
      carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.82;
    } else if(inBorder){
      carPos = candidate; map.setView(carPos, map.getZoom(), { animate:false }); speed *= 0.72;
    } else {
      // offroad bounce: stronger
      const backDistance = Math.max(1.0, moveMeters * 1.0);
      const backPos = destinationPoint(carPos.lat, carPos.lng, backDistance, (bearing + 180) % 360);
      carPos = backPos; map.setView(carPos, map.getZoom(), { animate:false });

      const bounceSpeed = Math.max(MIN_BOUNCE_SPEED, Math.abs(speed) * BOUNCE_FACTOR);
      speed = -bounceSpeed;

      carDiv.classList.add('bounce'); setTimeout(()=>carDiv.classList.remove('bounce'), 180);
      playBounceSound();
    }

    // pickups: pCar once
    const pCar = map.latLngToLayerPoint(carPos);
    for(let i = stars.length - 1; i >= 0; i--){
      const s = stars[i]; if(!s) continue;
      const pStar = map.latLngToLayerPoint(s.getLatLng());
      if(pCar.distanceTo(pStar) < PICKUP_PIXEL_DIST){
        map.removeLayer(s); stars.splice(i,1); score += 10; updateScore(); playPickupSound();
      }
    }

    // finish
    if(!finished && roads.length>0){
      const lastRoadLL = flattenLatLngs(roads[0].getLatLngs());
      const lastPoint = lastRoadLL[lastRoadLL.length-1];
      if(lastPoint && map.distance(carPos, lastPoint) <= FINISH_DISTANCE_METERS){ finished = true; finishOverlay.style.display = 'block'; playFinishSound(); }
    }
  }

  // rotation smoothing
  if(rotWrapper){
    const targetAngle = -headingDeg;
    const diff = shortestAngleDiff(targetAngle, displayedAngle);
    const step = diff * (1 - Math.exp(-8 * dt));
    displayedAngle += step;
    if(Math.abs(shortestAngleDiff(targetAngle, displayedAngle)) < 0.02) displayedAngle = ((targetAngle%360)+360)%360;
    rotWrapper.style.transform = `rotate(${displayedAngle}deg)`;
  }

  // car lean
  let angularVelocity = 0; if(keys.ArrowLeft) angularVelocity = -ROTATION_SPEED; if(keys.ArrowRight) angularVelocity = ROTATION_SPEED;
  const tiltMax = 12;
  const lean = (angularVelocity / ROTATION_SPEED) * (Math.min(Math.abs(speed)/MAX_FORWARD_SPEED, 1)) * tiltMax;
  carDiv.style.transform = `translate(-50%,-50%) rotate(${lean}deg)`;

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// fallback onRoad that uses dynamic per-segment latLng->layer conversions if needed
function onRoad(latlng, pixelTolerance = 12){
  if(roads.length === 0) return false;
  const p = map.latLngToLayerPoint(latlng);
  for(let ri=0; ri<roads.length; ri++){
    let latlngs = roads[ri].getLatLngs();
    if(Array.isArray(latlngs[0]) && latlngs[0] && typeof latlngs[0].lat === 'undefined') latlngs = latlngs.flat();
    for(let i=0;i<latlngs.length-1;i++){
      const a = map.latLngToLayerPoint(latlngs[i]); const b = map.latLngToLayerPoint(latlngs[i+1]);
      if(L.LineUtil.pointToSegmentDistance(p,a,b) <= pixelTolerance) return true;
    }
  }
  return false;
}

// rebuild pixel segments initially if any roads exist
map.whenReady(()=>{ rebuildRoadPixelSegments(); 

alert("‚ÑπÔ∏è Driving: Arrowkeys. Change Speed: press keys 1-5")

});



// remove focus on click
map.on('click', ()=>{ try{ (document.activeElement||document.body).blur(); }catch(e){} });



// ---------------- Auto-load (optional) ----------------
(function autoLoadGeoJSON(){

const geojsonDataUrl = 'assets/json/strecken.json';


  fetch(geojsonDataUrl).then(res => { if(!res.ok) throw new Error('not found'); return res.json(); }).then(j => {
    if(!j || j.type !== 'FeatureCollection') return;
    clearRoads(); clearStars(); score = 0; updateScore(); finished = false; finishOverlay.style.display='none';
    let added = 0;
    j.features.forEach(fe => { if(!fe.geometry) return; const g = fe.geometry; if(g.type === 'LineString'){ addRoadFromCoords(g.coordinates); added++; } else if(g.type === 'MultiLineString'){ g.coordinates.forEach(line => addRoadFromCoords(line)); added++; } });
    if(added===0) return;
    placeStarsAll(STAR_SPACING);
    rebuildRoadPixelSegments();
    if(roads.length>0){ const latlngs = flattenLatLngs(roads[0].getLatLngs()); const start = latlngs[0]; if(start){ carPos = start; map.setView(carPos, MAP_ZOOM, {animate:false}); speed=0; headingDeg=180; displayedAngle=-headingDeg; if(rotWrapper) rotWrapper.style.transform=`rotate(${displayedAngle}deg)`; } }
    loaderEl.style.display = 'none';
    console.log('Auto-GeoJSON geladen: ' + added + ' Feature(s)');
  }).catch(()=>{});
})();
</script>
</body>
</html>
