<!doctype html>
<!-- 
‚ö†Ô∏è DANGER! This is a prototype. Use at your own risk.

Current Version: 2025-09-25_22.56
Invented by: Wolfmond

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org/>
-->
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Oldenburg Helirescue</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script>

const message = "‚ö†Ô∏è This is a highly experimental Prototype. Not yet intended for public use.  No Warranties. Use this software at your own risk. This website can be played with arrow keys on your keyboard on a Laptop/PC. Tested with Chrome & Brave. In my Tests: Runs best in Chrome Browser. Language (yet): GERMAN";


if (!confirm(message)) window.location.href = "about:blank";
alert('‚Ñπ\nDu bist im Helikopter der Oldenburger Notfallrettung und bekommst Eins√§tze zugewiesen. Du bringst Verunfallte zum Krankenhaus.');
alert('‚Ñπ\nSteuerung\nBild ‚Üë : hoch fliegen\nBild ‚Üì : runter fliegen\n1-7 : Geschwindigkeit\n ‚Üê‚Üë‚Üì‚Üí : Heli Steuern');
alert('‚Ñπ\nLande in den markierten Kreisen. Landen (Bild ‚Üì) geht erst, wenn du nicht mehr fliegst.');
alert('‚Ñπ\nStarte zu deinem ersten Einsatz. Halte Bild ‚Üë gedr√ºckt, um vom Boden abzuheben.');
alert('‚Ñπ\nViel Gl√ºck üçÄ.');
alert('‚Ñπ\n Ach, und noch etwas: Tanken kannst du im Hangar. Lande im Hangar, dann wird der Heli betankt. üçÄ.');


</script>
<style>
  html,body,#map{height:100%;margin:0;padding:0;font-family:system-ui,Arial,sans-serif;cursor:none;}
  #map{background:#e7eef8}
  .heli-center{  position: absolute;
  z-index: 12000;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%);
  width: 52px;
  height: 52px;
  border-radius: 50%;

  /* radial so, dass er bis zur Kreis-Kante geht und nur einmal auftaucht */
  background: radial-gradient(circle closest-side at 50% 50%, 
                             rgba(159, 60, 255, 0.5) 0%, 
                             rgba(40, 0, 50, 0.5) 100%);
  background-repeat: no-repeat;
  background-size: 100% 100%;
  background-position: center;

  /* verhindert, dass Hintergrund unter der Border sichtbar wird */
  background-clip: padding-box;

  border: 3px solid rgba(255,255,255,0.08);
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
}
  .heli-center svg{width:62%;height:62%}
  .hud{position:fixed;left:12px;top:12px;z-index:14000;background:rgba(255,255,255,0.95);padding:10px 12px;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.12);font-weight:700}
  .hint{position:fixed;left:50%;bottom:16px;transform:translateX(-50%);z-index:14000;background:rgba(255,255,255,0.9);padding:8px 12px;border-radius:8px;font-weight:600;display:none;}
  .status{font-weight:800;color:#7a00ff;margin-left:8px; display:none;}
  .leaflet-zoom-animated { transition: transform 320ms cubic-bezier(.25,.1,.25,1); will-change: transform; }
  .leaflet-tile { transition: opacity 220ms linear; will-change: opacity, transform; -webkit-backface-visibility: hidden; backface-visibility: hidden; }
  .leaflet-tile-loaded { opacity: 1; }
  .leaflet-tile:not(.leaflet-tile-loaded) { opacity: 0; }
  .leaflet-zoom-animated .leaflet-tile, .leaflet-zoom-hide .leaflet-tile { transition: opacity 220ms linear, transform 320ms cubic-bezier(.25,.1,.25,1); }
  .flash { display:inline-block; padding:2px 6px; border-radius:6px; background:rgba(255,200,200,0.95); color:#7a0010; font-weight:800; margin-left:8px; }
  
  #zoomLevel {display:none;}
  
  .konsolentext {flex:0 0 80px; text-align:right; font-size:14px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'DejaVu Sans Mono', monospace; font-variant-numeric: tabular-nums;}
  
  .left {text-align:left;}
  
  .big-h-icon { display: block; line-height: 0; }
  
.leaflet-container .leaflet-tile {
	filter: hue-rotate(var(--map-hue, 0deg))
	saturate(var(--map-sat, 1))
	contrast(var(--map-contrast, 1))
	brightness(var(--map-bright, 1))
	invert(var(--map-invert, 0))
	sepia(var(--map-sepia, 0))
	grayscale(var(--map-gray, 0))
	blur(var(--map-blur, 0px))
	drop-shadow(var(--map-shadow-x,0px) var(--map-shadow-y,0px) var(--map-shadow-blur,0px) var(--map-shadow-color,transparent));
	transition: filter 400ms ease;
}

 #cheat-console {
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100vw;
    max-height: 40vh;
    box-sizing: border-box;
    background: #000;
    color: #0f0;
    border-top: 4px solid #0a0;
    padding: 12px 16px;
    display: none;
    z-index: 1000000; /* >>> h√∂her als Overlay! */
    overflow: auto;
    font-family: monospace;
  }
  .console-row { display: flex; align-items: flex-start; gap: 8px; }
  .prompt { min-width: 18px; }
  #console-input {
    background: transparent;
    border: none;
    outline: none;
    color: inherit;
    font: inherit;
    width: 100%;
    caret-color: #0f0;
  }
  #console-log { white-space: pre-wrap; margin-bottom: 8px; }
  .hint2 { font-size: 12px; opacity: 0.7 }
</style>
</head>
<body>
<div id="map"></div>

<div class="heli-center" id="heliDiv" title="Heli">
<svg
   width="19.649965mm"
   height="21.987007mm"
   viewBox="0 0 19.649965 21.987007"
   version="1.1"
   id="svg5"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs2" />
  <g
     id="layer1"
     transform="translate(-97.537749,-87.877705)">
    <polygon
       points="86,86 14,86 50,8 "
       fill="#ff9ee7"
       stroke="rgba(255,255,255,0.12)"
       stroke-width="3"
       stroke-linejoin="round"
       id="polygon9"
       transform="matrix(0.26458333,0,0,0.26458333,94.133566,86.810546)"
       style="fill:#ff9ee7;fill-opacity:1;stroke:#000000;stroke-width:2.26772;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;opacity:0.8" />
    <circle
       style="fill:#ff9ee7;fill-opacity:1;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:29.7449;stroke-opacity:1;paint-order:stroke fill markers;opacity:0.8"
       id="path40"
       cx="107.36273"
       cy="89.179474"
       r="0.80176884" />
  </g>
</svg>

</div>

<div class="hud konsolentext" id="hud">Speed: <span id="speed">0.0</span> m/s ‚Äî Max: <span id="maxSpeed">30</span> m/s <span id="zoomLevel">17</span> <span class="status" id="landState"></span></div>
<div class="hint">Steuerung: Pfeiltasten = lenken / Gas / Bremse ‚Ä¢ 1‚Äì9 = Max Speed ‚Ä¢ Leertaste = Pause ‚Ä¢ Bild‚Üë/Bild‚Üì = H√∂he √§ndern (14‚Äì18 beim Flug, 19 = Landen wenn gestoppt). Bei Landung werden Bewegung/Lenkung deaktiviert ‚Äî Bild‚Üë (PageUp) bleibt aktiv, damit du wieder steigen (take-off) kannst.</div>

<!-- Cheat-Konsole -->
<div id="cheat-console" role="dialog" aria-label="Cheat-Konsole">
  <div id="console-log" aria-live="polite"></div>
  <div class="console-row">
    <div class="prompt">&gt;</div>
    <input id="console-input" autocomplete="off" autofocus spellcheck="false" aria-label="Konsoleneingabe" />
  </div>
  <div class="hint2">Dr√ºcke die Taste ~ (Tilde), um die Konsole zu √∂ffnen/schlie√üen. Esc schlie√üt sie ebenfalls.</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// --- Konfiguration ---
const STARTPOS = [53.137181, 8.255045];
let ZOOM = 19; // initial (start in landed view)
let ZOOM_MIN = 15;
const ZOOM_MAX_SAFE = 18;
const ZOOM_LAND = 19;

const GEARS = {
  1: 0, 2: 6, 3: 12, 4: 24, 5: 40, 6: 60, 7: 80
};
let currentGear = 5;
let lastGearChangeTime = 0;
let MAX_SPEED = GEARS[currentGear];

let ACCEL = 12; // m/s^2
const FRICTION = 1.5; // m/s^2
let BRAKE_DECEL = 6; // m/s^2

// --- Wind (pro Quest) ---
let wind = { speed:0, dir:0, gustAmp:0, gustFreq:0, seed:0 };
const MAX_WIND = 0.1;
const BOOST_WIND_LIMIT = 12;
const LAND_WIND_MAX = 3;


// --- Fuel System (einf√ºgen nach "// --- Fahrzeugzustand ---") ---
const MAX_FUEL = 100;            // in Prozent
let fuel = MAX_FUEL;             // aktueller Treibstoff (Prozent)
let fuelPercent = Math.ceil(fuel);
let outOfFuel = false;           // true wenn Motor komplett ausgefallen

// Tunable Einstellungen (bleiben wie gew√ºnscht)
const FUEL_CONFIG = {
  base: 0.1,       // %/s Grundverbrauch (Motor an, Leerlauf)
  throttle: 0.18,  // zus√§tzlicher %/s wenn voller Schub (throttleInput==1)
  speed: 0.002,    // alte speed-Komponente (wird ignoriert zugunsten RANGE_KM, kann 0 bleiben)
  boost: 0.0       // extra %/s wenn Boost aktiv
};

// --- Neue, einfache Range-basierte Einstellung ---
// wie viele Kilometer schafft ein voller Tank (100%) wenn nur Distanz z√§hlt
let RANGE_KM = 50; // funktioniert noch nicht ganz, deswegen...
RANGE_KM = RANGE_KM*2; // ... wird es hier f√ºr das Gameplay ver√§ndert.

// Minimaler Treibstoff zum Starten (in %)
const MIN_FUEL_TO_LAUNCH = 3;

// --- Hangar / Refuel Config (nach Fuel-Variablen) ---
const HANGAR_RADIUS = 20; // Meter
let hangarCircle = null;  // Leaflet circle instance
let refueling = false;    // true w√§hrend Betankung
let controlsDisabled = false; // deaktiviert Tastatureingaben w√§hrend Betankung
let refuelSavedQuestText = null; // Questtext sichern vor Betankung

const REFUEL_RATE = 2.56267; // % pro Sekunde (bei 25 => ~4s von 0->100)


let _prevNavDist = '';
let _prevNavWind = '';
let _prevArrowRot = null;
let _lastNavUpdate = 0; // ms - rate-limit

let navArrowSVG = null;
let navDist = null;
let navWindEl = null;


function getCurrentWindSpeed(){
  if(!wind) return 0;
  const now = performance.now() / 1000;
  const gustNow = wind.gustAmp ? (wind.gustAmp * Math.sin(now * wind.gustFreq * Math.PI * 2 + wind.seed)) : 0;
  return Math.max(0, wind.speed + gustNow);
}

// --- Karte ---
const map = L.map('map', {
  keyboard:false,
  zoomControl:false,
  attributionControl:true,
  zoomAnimation: true,
  zoomSnap: 0.25,
  zoomDelta: 0.5,
  inertia: false
}).setView(STARTPOS, ZOOM);

// disable user interaction with map to keep game controls exclusive
map.dragging.disable();
map.scrollWheelZoom.disable();
map.doubleClickZoom.disable();
map.boxZoom.disable();
map.touchZoom.disable();
if (map.tap) map.tap.disable();
map.keyboard.disable();

L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom:19,
  attribution: '<a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noreferrer">¬© OpenStreetMap contributors</a>',
  keepBuffer: 2,
  updateWhenZooming: true,
  reuseTiles: true
}).addTo(map);
map.eachLayer(layer=>{ if(layer instanceof L.TileLayer){
  layer.on('tileload', (ev)=> { ev.tile.classList.add('leaflet-tile-loaded'); });
  layer.on('tileunload', (ev)=> { ev.tile.classList.remove('leaflet-tile-loaded'); });
}});


 

    // Gr√∂√üe des Icons in Pixel (Durchmesser des Kreises)
    const size = 56; // z.B. 56px, anpassen nach Wunsch
    const fontSize = 28; // Schriftgr√∂√üe 'H'
	
	const hangar = [(STARTPOS[0]+0.0001),STARTPOS[1]]

    // SVG-HTML f√ºr Kreis + Buchstabe H (zentriert)
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
        <!-- Kreis -->
        <circle cx="${size/2}" cy="${size/2}" r="${(size/2)-1}" fill="white" stroke="#2b7bb9" stroke-width="2"/>
        <!-- Buchstabe H (mittig) -->
        <text x="50%" y="50%" text-anchor="middle" dominant-baseline="central"
              font-family="Arial, Helvetica, sans-serif" font-size="${fontSize}" font-weight="700" fill="#2b7bb9">H</text>
      </svg>
    `;

    // DivIcon erstellen: className leer lassen, damit Leaflet nicht zus√§tzliche Styles setzt
    const icon = L.divIcon({
      html: `<div class="big-h-icon">${svg}</div>`,
      className: '',            // keine extra Leaflet-Klasse (oder setze eigene Klasse)
      iconSize: [size, size],
      iconAnchor: [size/2, size/2] // Mitte des Icons an der Koordinate
    });

    // Marker mit dem Icon
    L.marker(hangar, { icon }).addTo(map);

    // --- Hangar Circle: sichtbar nur auf Zoom 19 ---
function createHangarCircle(){
  // style: halb-rot (fill transparent-ish)
hangarCircle = L.circle(hangar, {
  radius: HANGAR_RADIUS,
  color: '#b41414',     // Randfarbe (ohne Alpha)
  opacity: 0.95,        // Transparenz f√ºr den Rand
  weight: 2,            // Randdicke
  fillColor: '#b41414', // F√ºllfarbe (ohne Alpha)
  fillOpacity: 0.52,    // Transparenz f√ºr die F√ºllung
  interactive: false
}).addTo(map);

  // initial visibility (nur bei Landen-Zoom)
  updateHangarVisibility();

  // bei Zoom-√Ñnderungen anpassen
  map.on('zoomend', updateHangarVisibility);
}

function updateHangarVisibility(){
  if(!hangarCircle) return;
  const z = Math.round(map.getZoom());
  if(z === ZOOM_LAND){ // 19
    hangarCircle.setStyle({opacity:1, fillOpacity:0.12});
  } else {
    // 'ausblenden' durch 0-Opacity (bleibt im Layer)
    hangarCircle.setStyle({opacity:0, fillOpacity:0});
  }
}

// Erzeuge die Anzeige (aufrufen nachdem 'hangar' definiert und map initialisiert ist)
createHangarCircle();

     
	


// --- Fahrzeugzustand ---
let heliPos = L.latLng(STARTPOS[0], STARTPOS[1]);
let headingDeg = 0; // 0 = Norden
let speed = 0; // AIRSPEED in m/s (pilot-set)
let paused = true;

// auto-pan protection
let autoPanSuspended = false;
let pendingAutoPan = false;
function suspendAutoPanUntilZoomEnd(){
  autoPanSuspended = true;
  pendingAutoPan = true;
  const handler = ()=>{
    if(!autoPanSuspended) return;
    autoPanSuspended = false;
    if(pendingAutoPan){
      map.panTo(heliPos, {animate:false});
      pendingAutoPan = false;
    }
    updateZoomUI();
    if(typeof checkQuestProgress === 'function') checkQuestProgress();
  };
  map.once('zoomend', handler);
  map.once('moveend', handler);
}

function degToCompass(deg, opts = {}) {
  // opts.from = true -> interpretiere deg als "to"-bearing und gib "from"-Kompass zur√ºck
  if (typeof deg !== 'number') deg = 0;
  if (opts.from) {
    deg = (deg + 180) % 360;
  }
  const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
  const ix = Math.floor(((deg + 11.25) % 360) / 22.5);
  return dirs[ix];
}

let flashTimeout = null;
function flashMessage(txt){
  const el = document.getElementById('landState');
  el.textContent = ' ' + txt;
  if(flashTimeout) clearTimeout(flashTimeout);
  flashTimeout = setTimeout(()=>{ updateZoomUI(); flashTimeout = null; }, 1400);
}

let boostActive = false;
const BOOST_MULT = 20.5;
let BOOST_ACCEL_MULT = 6; // beim Boost wir die Beschleunigung um den Faktor 6 erh√∂ht (anpassen)

if (typeof window._disableBoost === 'undefined') {
  window._disableBoost = false;
}

// --- Eingabe ---
const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
document.addEventListener('keydown', (e)=>{
  if((e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA')) ) return;
  if(controlsDisabled){
    // verhindern, dass Tasten Aktionen ausl√∂sen (inkl. PageUp)
    e.preventDefault();
    return;
  }
  if(e.key === 'Shift' && !window._disableBoost) boostActive = true;
  if(e.key === ' ') { e.preventDefault(); paused = !paused; return; }

  if(e.key >= '1' && e.key <= '9'){
    const g = parseInt(e.key, 10);
    if(GEARS.hasOwnProperty(g)){
      currentGear = g;
      MAX_SPEED = GEARS[currentGear];
      lastGearChangeTime = performance.now();
      document.getElementById('maxSpeed').textContent = Math.round(MAX_SPEED);
    } else {
      flashMessage('Gang nicht verf√ºgbar');
    }
    return;
  }

  if(e.key === 'PageUp' || e.key === 'PageDown'){
    e.preventDefault(); handleAltitudeKey(e.key === 'PageUp'); return;
  }

  if(isLanded()){
    return;
  }

  if(e.key in keys){ keys[e.key] = true; e.preventDefault(); }
});
document.addEventListener('keyup', (e)=>{ 
  if(e.key in keys){ keys[e.key] = false; e.preventDefault(); }
  if(e.key === 'Shift' && !window._disableBoost) boostActive = false;
});

// --- Altitude / Zoom-Logik ---
function startFlyToZoom(targetZoom, duration = 0.36){
  suspendAutoPanUntilZoomEnd();
  map.flyTo(heliPos, targetZoom, { animate: true, duration: duration, easeLinearity: 0.25 });
}
function isLanded(){
  return Math.round(map.getZoom()) === ZOOM_LAND;
}

function handleAltitudeKey(isPageUp){
  if(controlsDisabled){
    flashMessage('Steuerung deaktiviert w√§hrend Betankung');
    return;
  }

  const cur = map.getZoom();

if(isLanded()){
      if(isPageUp){
        // prevent takeoff when not enough fuel
        if(fuel <= MIN_FUEL_TO_LAUNCH || outOfFuel){
          //flashMessage('Zu wenig Treibstoff zum Starten');
          outOfFuel = true;
			handleFuelEmptyEmergency('Zu wenig Treibstoff zum Starten. Du brauchst mehr als 3 % Treibstoff, um zu starten. Tanke das n√§chste mal rechtzeitig; fliege daf√ºr einfach den Hangar an, wo du gestartet bist, und lande dort. Der Heli wird dann betankt.');
          return;
        }
        // take-off
        startFlyToZoom(ZOOM_MAX_SAFE, 0.45);
        paused = false;
        updateZoomUI();
      }
      return;
    }

  if(isPageUp){
    if(paused) paused = false;
    if(cur <= ZOOM_MIN) return;
    const next = Math.max(ZOOM_MIN, cur - 1);
    startFlyToZoom(next, 0.36);
    updateZoomUI();
    return;
  } else {
    if(cur < ZOOM_MAX_SAFE){
      const next = Math.min(ZOOM_MAX_SAFE, cur + 1);
      startFlyToZoom(next, 0.36);
      updateZoomUI();
      return;
    }

    // Attempt to land: speed must be ~0 and current wind must be acceptable
    if(Math.abs(speed) <= 0.0001){
      const currentWind = getCurrentWindSpeed();
      if(currentWind > LAND_WIND_MAX){
        flashMessage('Zu starker Wind zum Landen');
        return;
      }
      startFlyToZoom(ZOOM_LAND, 0.45);
      paused = true;
      updateZoomUI();
    } else {
      flashMessage('‚Äî Nicht landen: zuerst anhalten');
    }
  }
}

// --- UI Update ---
function updateZoomUI(){ 
  const z = map.getZoom();
  document.getElementById('zoomLevel').textContent = Number(z).toFixed(2).replace('.00',''); 
  const state = document.getElementById('landState');
  if(Math.round(z) === ZOOM_LAND){ state.textContent = ' (Gelandet ‚Äî Steuerung deaktiviert; Bild‚Üë bleibt aktiv)'; }
  else if(z >= ZOOM_MAX_SAFE){ state.textContent = ' (In-flight: n√§her)'; }
  else if(z <= ZOOM_MIN+0.1){ state.textContent = ' (In-flight: weit)'; }
  else { state.textContent = ''; }
}

// --- Haversine-ish helper ---
const R = 6378137; 
function toRad(d){return d*Math.PI/180;} 
function toDeg(r){return r*180/Math.PI;} 

function destinationPoint(lat, lon, distanceMeters, bearingDeg){
  const Œ¥ = distanceMeters / R;
  const Œ∏ = toRad(bearingDeg);
  const œÜ1 = toRad(lat);
  const Œª1 = toRad(lon);
  const sinœÜ1=Math.sin(œÜ1), cosœÜ1=Math.cos(œÜ1);
  const sinŒ¥=Math.sin(Œ¥), cosŒ¥=Math.cos(Œ¥);
  const œÜ2 = Math.asin(sinœÜ1*cosŒ¥ + cosœÜ1*sinŒ¥*Math.cos(Œ∏));
  const Œª2 = Œª1 + Math.atan2(Math.sin(Œ∏)*sinŒ¥*cosœÜ1, cosŒ¥ - sinœÜ1*Math.sin(œÜ2));
  return L.latLng(toDeg(œÜ2), toDeg(Œª2));
}

// sehr einfache, nicht rechenintensive Wetter-Visuals
function applyWeatherVisuals(w, map) {
  const MIN_SAT = 0.2;
  const MAX_SAT = 0.3;

  // Bestimme das Element, auf dem wir die CSS-Variable setzen:
  // wenn eine Leaflet map-Instanz √ºbergeben wurde, nutzen wir deren Container,
  // sonst document.documentElement (root).
  const rootEl = (map && typeof map.getContainer === 'function')
    ? map.getContainer()
    : document.documentElement;

  if (w === 'dunst') {
    // einmaliger, leicht variierender S√§ttigungswert pro Aufruf
    const sat = (Math.random() * (MAX_SAT - MIN_SAT) + MIN_SAT).toFixed(2);
    // setze die CSS-Variable (kein "px" n√∂tig ‚Äî saturate() erwartet eine Zahl)
    rootEl.style.setProperty('--map-sat', sat);
    // optional: Klasse zum Container, falls du weitere dunst-spezifische Regeln m√∂chtest
    rootEl.classList.add('weather-dunst');
  } else {
    // entferne die Variable / Klasse wieder, falls kein Dunst mehr
    rootEl.style.removeProperty('--map-sat');
    rootEl.classList.remove('weather-dunst');
  }
}



// ---------------- Quests & Landing overlay ----------------
const LAND_RADIUS = 20;
let quests = [];
let currentQuestIndex = -1;
let currentQuest = null;
let questState = null;
function createLandingOverlay(latlng, meterRadius = 20, opts = {}){
  const color = opts.color || 'red';
  const strokeWidth = (typeof opts.weight === 'number') ? opts.weight : 2;
  const fillOpacity = (typeof opts.fillOpacity === 'number') ? opts.fillOpacity : 0.12;

  // --- ensure a dedicated pane for landing overlays (low z-index) ---
  // createPane ist idempotent (erstellt nur, wenn noch nicht vorhanden)
  try{
    if(!map.getPane('landingPane')){
      map.createPane('landingPane');
      // z-index w√§hlen: kleiner als markerPane; Default markerPane ist 600,
      // overlayPane liegt typischerweise bei 400. Wir setzen landingPane bewusst darunter.
      map.getPane('landingPane').style.zIndex = 350;
      // optional: pointer-events none f√ºr ganze Pane (wir stellen es auch auf Container)
      map.getPane('landingPane').style.pointerEvents = 'none';
    }
  }catch(e){
    // fallback: benutze overlayPane, falls createPane nicht verf√ºgbar
  }

  const pane = map.getPane('landingPane') || map.getPanes().overlayPane;

  const container = L.DomUtil.create('div', 'landing-overlay');
  container.style.position = 'absolute';
  container.style.pointerEvents = 'none';
  container.style.transformOrigin = '0 0';
  container.style.willChange = 'transform';
  // setze expliziten zIndex am Element als weitere Absicherung
  container.style.zIndex = '1';

  pane.appendChild(container);

  function metersToPx(meters, centerLatLng) {
    const center = toLatLngObj(centerLatLng);
    if(!center) return 1;
    const pCenter = map.latLngToLayerPoint(center);
    const eastLatLng = destinationPoint(center.lat, center.lng, meters, 90);
    const pEast = map.latLngToLayerPoint(eastLatLng);
    return Math.max(1, Math.abs(pEast.x - pCenter.x));
  }

  function update(){
    try{
      const pt = map.latLngToLayerPoint(toLatLngObj(latlng));
      const pxR = metersToPx(meterRadius, latlng);
      const size = Math.ceil(pxR * 2 + strokeWidth * 2);
      const left = Math.round(pt.x - pxR - strokeWidth);
      const top = Math.round(pt.y - pxR - strokeWidth);
      container.style.width = size + 'px';
      container.style.height = size + 'px';
      container.style.left = left + 'px';
      container.style.top = top + 'px';
      const cx = Math.round(size / 2), cy = cx, r = Math.round(pxR);
      container.innerHTML = `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg"><circle cx="${cx}" cy="${cy}" r="${r}" stroke="${color}" stroke-width="${strokeWidth}" fill="${color}" fill-opacity="${fillOpacity}"></circle></svg>`;
    }catch(e){}
  }

  const bound = ()=> update();
  map.on('move', bound);
  map.on('zoom', bound);
  map.on('zoomanim', bound);
  map.on('viewreset', bound);
  update();

  return {
    el: container,
    stop() {
      map.off('move', bound);
      map.off('zoom', bound);
      map.off('zoomanim', bound);
      map.off('viewreset', bound);
      try { pane.removeChild(container); } catch(e){}
    }
  };
}


// Bearing helper
function bearingBetween(a, b){
  const A = toLatLngObj(a), B = toLatLngObj(b);
  const œÜ1 = toRad(A.lat), œÜ2 = toRad(B.lat);
  const ŒîŒª = toRad(B.lng - A.lng);
  const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
  const x = Math.cos(œÜ1)*Math.sin(œÜ2) - Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(ŒîŒª);
  const Œ∏ = Math.atan2(y, x);
  return (toDeg(Œ∏) + 360) % 360;
}

function toLatLngObj(v){
  if(!v) return null;
  if(typeof v.lat === 'number' && typeof v.lng === 'number') return v;
  if(Array.isArray(v)) return L.latLng(v[0], v[1]);
  if(typeof v === 'object' && typeof v[0] === 'number') return L.latLng(v[0], v[1]);
  return null;
}

function shuffleArray(arr){
  for(let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function distanceMetersBetween(a,b){
  const A = toLatLngObj(a), B = toLatLngObj(b);
  if(!A || !B) return Infinity;
  const œÜ1 = toRad(A.lat), Œª1 = toRad(A.lng), œÜ2 = toRad(B.lat), Œª2 = toRad(B.lng);
  const ŒîœÜ = œÜ2 - œÜ1, ŒîŒª = Œª2 - Œª1;
  const ha = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(ha), Math.sqrt(1-ha));
  return R * c;
}

// HUD nav
let navBox = document.getElementById('navBox');
if(!navBox){
// --- NAV-BOX (stabiles Layout, feste Spalten, keine Wanderungen) ---
navBox = document.createElement('div');
navBox.id = 'navBox';
navBox.style.position = 'fixed';
navBox.style.right = '12px';
navBox.style.bottom = '12px';
navBox.style.zIndex = 15000;
navBox.style.background = 'rgba(255,255,255,0.95)';
navBox.style.borderRadius = '10px';
navBox.style.boxShadow = '0 6px 18px rgba(0,0,0,0.12)';
navBox.style.display = 'none';

// Layout / fixe Gr√∂√üe
navBox.style.width = '320px';         // fixe Gesamtbreite (anpassen falls n√∂tig)
navBox.style.boxSizing = 'border-box';
navBox.style.padding = '8px 10px';
navBox.style.overflow = 'hidden';
navBox.style.whiteSpace = 'nowrap';
//navBox.style.fontWeight = '800';
//navBox.style.fontFamily = "ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial";
navBox.style.display = 'flex';
navBox.style.alignItems = 'center';
navBox.style.gap = '8px';
navBox.style.transition = 'opacity 120ms linear';
navBox.classList.add('konsolentext');

// feste Inhalte (feste Flex-Basis / monospace f√ºr Zahlen)
navBox.innerHTML = `
  <div id="navArrow" style="flex:0 0 48px; display:flex; align-items:center; justify-content:center;">
    <svg viewBox="0 0 100 100" id="navArrowSVG" style="width:38px;height:38px; will-change:transform; transform-origin:50% 50%;">
      <polygon points="50,6 86,90 50,72 14,90" fill="#7a00ff" stroke="rgba(0,0,0,0.08)" stroke-width="2"/>
    </svg>
  </div>

  <div id="navDist" style="flex:0 0 80px; text-align:right; font-size:14px;
       font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'DejaVu Sans Mono', monospace;
       font-variant-numeric: tabular-nums;">
    ‚Äî km
  </div>

  <div id="navWind" style="flex:0 0 116px; text-align:right; font-size:13px;
       font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'DejaVu Sans Mono', monospace;
       font-variant-numeric: tabular-nums;">
    Wind: ‚Äî m/s
  </div>
`;
document.body.appendChild(navBox);

navArrowSVG = document.getElementById('navArrowSVG');
navDist = document.getElementById('navDist');
navWindEl = document.getElementById('navWind');

// --- Quest-Container + "Erledigte Quests"-Box -----------------
(function ensureQuestContainerAndCompletedBox(){
  // 1) Container erstellen (falls nicht vorhanden)
  let qCont = document.getElementById('questContainer');
  if(!qCont){
    qCont = document.createElement('div');
    qCont.id = 'questContainer';
    Object.assign(qCont.style, {
      position: 'fixed',
      left: '12px',
      top: '64px',
      zIndex: 14000,
      display: 'flex',
      flexDirection: 'column',
      gap: '8px',
      alignItems: 'flex-start',
      pointerEvents: 'auto'
    });
    document.body.appendChild(qCont);
  }

  // 2) QuestBox: falls vorhanden, ins Container verschieben; sonst neu erstellen (leicht angepasst)
  let qb = document.getElementById('questBox');
  if(!qb){
    qb = document.createElement('div');
    qb.id = 'questBox';
    Object.assign(qb.style, {
      background: 'rgba(255,255,255,0.95)',
      padding: '8px 12px',
      borderRadius: '8px',
      fontWeight: '700',
      maxWidth: '36ch',
      boxSizing: 'border-box',
	  marginTop: '4px',
	  boxShadow: '0 8px 24px rgba(0,0,0,0.12)',
    });
    qb.classList.add('konsolentext','left');
    qCont.appendChild(qb);
  } else {
    // falls questBox schon existiert, entferne seine absolute Positionierung (falls vorhanden)
    qb.style.position = 'relative';
    qb.style.left = '';
    qb.style.top = '';
    // und falls es noch nicht im Container ist, verschieben
    if(qb.parentElement !== qCont){
      qCont.appendChild(qb);
    }
  }

  // 3) Completed Box (neu unter QuestBox)
  let cb = document.getElementById('completedBox');
  if(!cb){
    cb = document.createElement('div');
    cb.id = 'completedBox';
    Object.assign(cb.style, {
      background: 'rgba(255,255,255,0.95)',
      padding: '6px 10px',
      borderRadius: '8px',
      fontWeight: '700',
      maxWidth: '36ch',
      fontSize: '13px',
      color: '#333',
      boxSizing: 'border-box',
	  marginTop: '12px',
	  boxShadow: '0 8px 24px rgba(0,0,0,0.12)',
    });
    qCont.appendChild(cb);
  } else {
    if(cb.parentElement !== qCont) qCont.appendChild(cb);
  }

  // 5) Initiales Update
  updateCompletedBox(0,0);

  // convenience: export reference
  window.questContainer = qCont;
})();


}

function updateCompletedBox (i,i2){
const cbEl = document.getElementById('completedBox');
  if(cbEl) cbEl.textContent = `Erledigte Quests: ${i} von ${i2}`;
}

function showNavUI(show){
  navBox.style.display = show ? 'flex' : 'none';
}

// Quest visuals
let activeScenePulse = null;
let activeHospitalPulse = null;

// load quests
function loadQuests(path = 'quests.json'){
  return fetch(path).then(r=>{
    if(!r.ok) throw new Error('no file');
    return r.json();
  }).catch(err=>{
    console.warn('Quests load failed, using fallback examples.', err);
    return [
      {
        text: "Schwerer Unfall auf der A28 bei Oldenburg, Massenkarambolage. Ein Schwerverletzer mit Verdacht auf Sch√§del-Hirn-Trauma. Bitte Patient abholen und nach Klinikum Oldenburg bringen.",
        location: [53.1438, 8.2250],
        hospital: { name: "Klinikum Oldenburg", location: [53.1443, 8.2192] }
      }
    ];
  }).then(data=>{
    const NUM_QUESTS = 3;
	const MAX_QUESTS = 30; // data slicing

    // --- LIMITIEREN auf die ersten 8 Eintr√§ge VOR dem Shufflen ---
    const limited = Array.isArray(data) ? data.slice(0, MAX_QUESTS) : [];

    // shuffleArray erwartet ein Array; hier wird das gek√ºrzte Array gemischt
    const shuffled = shuffleArray(limited.slice());

    // final: nimm bis zu NUM_QUESTS (wird durch `limited` automatisch begrenzt)
    quests = shuffled.slice(0, Math.min(NUM_QUESTS, shuffled.length));
    currentQuestIndex = -1;
	//console.log('Quests loaded:', quests.length, quests);
    startNextQuest();
  });
}


// start next quest & set wind
function startNextQuest(){
  if(activeScenePulse){ activeScenePulse.stop(); activeScenePulse = null; }
  if(activeHospitalPulse){ activeHospitalPulse.stop(); activeHospitalPulse = null; }
  currentQuestIndex++;
  
  updateCompletedBox(currentQuestIndex,quests.length);
  
  if(currentQuestIndex >= quests.length){
    currentQuest = null; questState = null;
    showNavUI(false);
    flashMessage('Alle Eins√§tze erledigt ‚Äî Spielende');
    let qb = document.getElementById('questBox');
    if(qb) qb.textContent = 'Alle Eins√§tze erledigt ‚Äî Gl√ºckwunsch!';
    return;
  }

  currentQuest = quests[currentQuestIndex];
  questState = 'toScene';
  
  const weathers = ['dunst']; 
weather = weathers[Math.floor(Math.random()*weathers.length)];
//console.log(weather);
applyWeatherVisuals(weather, map);

  // set per-quest wind (playable)
  (function setQuestWind(){
    wind.dir = Math.floor(Math.random() * 360);
    const r = Math.random();
    wind.speed = Math.round((Math.sqrt(r) * MAX_WIND) * 10) / 10;
    wind.gustAmp = Math.round(Math.min(0.45 * wind.speed, 6) * 10) / 10;
    wind.gustFreq = 0.15 + Math.random() * 0.2;
    wind.seed = Math.random() * Math.PI * 2;
    const qb = document.getElementById('questBox');
    if(qb){
      //qb.textContent = `Einsatz: ${currentQuest.text}\n‚Üí Lande im roten Kreis am Einsatzort\nWind: ${wind.speed} m/s Richtung ${wind.dir}¬∞ (Gust ¬±${wind.gustAmp} m/s)`;
      //qb.textContent = `Einsatz: ${currentQuest.text}\n‚Üí Lande im roten Kreis am Einsatzort`;
      qb.textContent = `Einsatz: ${currentQuest.text}`;
    }
  })();

  activeScenePulse = createLandingOverlay(currentQuest.location, LAND_RADIUS, { color: 'red', weight: 2, fillOpacity: 0.12 });
  activeHospitalPulse = null;

  flashMessage('Neue Quest: Einsatzort sichtbar');
  showNavUI(true);
}

// check progress (pickup/delivery) - now with wind check
function checkQuestProgress(){

  // Hangar-Refuel Check (zu Beginn von checkQuestProgress)
  (function(){
    const qb = document.getElementById('questBox');
    // nur wenn Hangar Kreis existiert & wir gelandet sind & nicht schon betankt wird
    if(hangarCircle && isLanded() && !refueling){
      const distToHangar = distanceMetersBetween(heliPos, hangar);
      if(distToHangar <= HANGAR_RADIUS && fuel < 100 && !outOfFuel){
        // save quest text (wenn noch nicht gesichert)
        if(qb) refuelSavedQuestText = qb.textContent;
        startRefuel();
        return; // kurz raus, refuel nimmt Priorit√§t
      }
    }
  })();


  if(!currentQuest) return;
  if(questState === 'toScene'){
    const dist = distanceMetersBetween(heliPos, currentQuest.location);
    if(dist <= LAND_RADIUS && isLanded() && Math.abs(speed) <= 0.0001 && getCurrentWindSpeed() <= LAND_WIND_MAX){
      if(activeScenePulse){ activeScenePulse.stop(); activeScenePulse = null; }
      flashMessage('Patient*in aufgenommen ‚Äî Krankenhaus jetzt sichtbar');
      questState = 'toHospital';
      activeHospitalPulse = createLandingOverlay(currentQuest.hospital.location, LAND_RADIUS, { color: 'blue' });
      let qb = document.getElementById('questBox');
      if(qb) qb.textContent = `Patient*in an Bord ‚Äî fliege zum Krankenhaus: ${currentQuest.hospital.name}`;
    }
  } else if(questState === 'toHospital'){
    const dist = distanceMetersBetween(heliPos, currentQuest.hospital.location);
    if(dist <= LAND_RADIUS && isLanded() && Math.abs(speed) <= 0.0001 && getCurrentWindSpeed() <= LAND_WIND_MAX){
      if(activeHospitalPulse){ activeHospitalPulse.stop(); activeHospitalPulse = null; }
      flashMessage('Patient*in abgeliefert ‚Äî Einsatz abgeschlossen');
	  let qb = document.getElementById('questBox');
      if(qb) qb.textContent = `Einsatz ${currentQuestIndex+1} abgeschlossen`;
      setTimeout(()=>{ startNextQuest(); }, 900);
    }
  }
}

// update navigation UI
function updateNavigationUI(){
  // Rate-limit: nicht √∂fter als ~10x/s updaten (100 ms)
  const nowMs = performance.now();
  if(nowMs - _lastNavUpdate < 80) return;
  _lastNavUpdate = nowMs;

  if(!currentQuest){ showNavUI(false); return; }
  const target = (questState === 'toScene') ? currentQuest.location : (currentQuest.hospital && currentQuest.hospital.location);
  if(!target){ showNavUI(false); return; }

  // Distanztext
  const distM = distanceMetersBetween(heliPos, target);
  const distText = `${(distM/1000).toFixed(2)} km`;

  // Wind-Text
  const t = performance.now() / 1000;
  const gustNow = wind && wind.gustAmp ? (wind.gustAmp * Math.sin(t * wind.gustFreq * Math.PI * 2 + wind.seed)) : 0;
  const currentWind = Math.round(( (wind && wind.speed ? wind.speed : 0) + gustNow) * 10) / 10;
  const dirStr = degToCompass(wind && wind.dir ? wind.dir : 0, { from: true });
  const windText = `Wind: ${currentWind.toFixed(1)} m/s aus ${dirStr}`;

  // Arrow-Rotation (absolute bearing)
  const absBearing = bearingBetween(heliPos, target); // 0..360
  const rot = Math.round(absBearing); // simple integer deg
  const ROT_THRESHOLD = 2; // nur drehen bei >2¬∞ √Ñnderung

  // Update nur wenn sich etwas ge√§ndert (vermeidet DOM writes)
  if(distText !== _prevNavDist){
    navDist.textContent = distText;
    _prevNavDist = distText;
  }
  if(windText !== _prevNavWind){
    if(navWindEl) navWindEl.textContent = windText;
    _prevNavWind = windText;
  }
  if(_prevArrowRot === null || Math.abs(rot - _prevArrowRot) > ROT_THRESHOLD){
    if(navArrowSVG){
      navArrowSVG.style.transform = `rotate(${rot}deg)`;
    }
    _prevArrowRot = rot;
  }

  showNavUI(true);
}

// HUD-Update (nutzt bereits vorhandene DOM-Elemente aus deinem HUD-Snippet)
function updateFuelHUD(){
  // clamp & Prozent
  const pct = Math.max(0, Math.min(100, fuel));
  fuelPercent = Math.ceil(pct);

  // DOM-Elemente (erwartet in deinem HUD vorhanden)
  const txt = document.getElementById('fuelPercentTxt'); // Text: "42%"
  const bar = document.getElementById('fuelBar');        // innerer Balken (skalieren)
  const kmEl = document.getElementById('fuelKmTxt');     // optional: "x km"
  const etaEl = document.getElementById('fuelETA');      // optional: "ETA: 12:34"
  const container = document.getElementById('fuelMeter'); // optional: um pulsing class zu toggeln

  // --- Einmalig: n√∂tige CSS-Regeln injizieren (smooth transform & low-flash) ---
  if(!window._fuelHudStylesInjected){
    const style = document.createElement('style');
    style.id = 'fuelHudStyles';
    style.textContent = `
      #fuelBar { transform-origin: left center; transition: transform 280ms linear, background 200ms linear; }
      .fuel-low-flash { animation: fuelFlash 1s ease-in-out infinite; }
      @keyframes fuelFlash {
        0% { box-shadow: 0 0 0 0 rgba(255,0,0,0.0); }
        50% { box-shadow: 0 0 8px 3px rgba(255,0,0,0.22); }
        100% { box-shadow: 0 0 0 0 rgba(255,0,0,0.0); }
      }
      .fuel-refuel-glow { animation: refuelGlow 1s ease-in-out infinite; }
      @keyframes refuelGlow {
        0% { box-shadow: 0 0 0 0 rgba(0,200,100,0.0); }
        50% { box-shadow: 0 0 10px 4px rgba(0,200,100,0.18); }
        100% { box-shadow: 0 0 0 0 rgba(0,200,100,0.0); }
      }
    `;
    document.head.appendChild(style);
    window._fuelHudStylesInjected = true;
  }

  // Text-Update
  if(txt) txt.textContent = `${fuelPercent}%`;

  // Balken-Update (performant via transform)
  if(bar){
    // Transform (scaleX: 0..1)
    const scale = Math.max(0, Math.min(1, fuelPercent / 100));
    bar.style.transform = `scaleX(${scale})`;
    // sanfte Transition setzen (falls noch nicht)
    if(!bar.style.transition) bar.style.transition = 'transform 280ms linear, background 200ms linear';

    // Farbe
    if(fuelPercent > 30) bar.style.background = 'green';
    else if(fuelPercent > 10) bar.style.background = 'orange';
    else bar.style.background = 'red';
  }

  // Reichweite (km) anzeigen, falls RANGE_KM verf√ºgbar und ein Element existiert
  if(typeof RANGE_KM === 'number' && kmEl){
    const kmRemaining = (fuel / 100) * RANGE_KM;
    kmEl.textContent = `${kmRemaining.toFixed(1)} km`;
  }

  // ETA bis leer in hh:mm:ss (wenn speed vorhanden und > 0)
  if(etaEl){
    const spd = (typeof speed === 'number') ? Math.abs(speed) : 0;
    if(spd > 0.001){ // g√ºltige Geschwindigkeit
      // kmRemaining -> Meter / speed (m/s) -> Sekunden
      const metersLeft = (fuel / 100) * RANGE_KM * 1000;
      const secsLeft = metersLeft / spd;
      etaEl.textContent = `ETA leer: ${formatSecondsAsHMS(secsLeft)}`;
    } else {
      etaEl.textContent = 'ETA leer: ‚Äî';
    }
  }

  // Refuel / low fuel Visuals am Container toggeln (falls vorhanden)
  if(container){
    container.classList.remove('fuel-low-flash', 'fuel-refuel-glow');
    if(refueling){
      container.classList.add('fuel-refuel-glow');
    } else if(fuelPercent <= 10){
      container.classList.add('fuel-low-flash');
    }
  }

  // Accessibility: live region f√ºr Screenreader, falls vorhanden (id: fuelLive)
  const live = document.getElementById('fuelLive');
  if(live){
    live.textContent = refueling ? `Tankt‚Ä¶ ${fuelPercent}%` : `Treibstoff ${fuelPercent}%`;
  }

  // Hilfsfunktion: Sekunden in H:MM:SS
  function formatSecondsAsHMS(s){
    if(!isFinite(s) || s <= 0) return '0:00';
    s = Math.round(s);
    const h = Math.floor(s / 3600);
    const m = Math.floor((s % 3600) / 60);
    const sec = s % 60;
    if(h > 0) return `${h}:${m.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
    return `${m}:${sec.toString().padStart(2,'0')}`;
  }
}


// consumption in percent per second (aufgerufen pro Frame mit dt in Sekunden)
function consumeFuel(dt, throttleInput, currentSpeed, isBoost){
  if(outOfFuel) return;

  // Basisformel: base + throttle-term + speed-term + boost
  // Beispiel: base 0.01 + throttle 0.18*1 + speed 0.002*30 + boost 1 => ~1.79 %/s
  let consumptionPerSec = FUEL_CONFIG.base
                         + FUEL_CONFIG.throttle * Math.abs(throttleInput)
                         + FUEL_CONFIG.speed * Math.abs(currentSpeed)
                         + (isBoost ? FUEL_CONFIG.boost : 0);

  // subtrahiere entsprechend dt
  fuel -= consumptionPerSec * dt;

  if(fuel <= 0){
    fuel = 0;
    outOfFuel = true;
    flashMessage('Kein Treibstoff ‚Äî Motor ausgefallen');
    // optional: setze boost/inputs zur√ºck (wird in animate weiter beachtet)
  }

  updateFuelHUD();
}

function startRefuel(){
  if(refueling) return;
  refueling = true;
  controlsDisabled = true;   // deaktiviert Tastatur-Handling (s.o.)
  boostActive = false;       // Boost ausschalten
  paused = true;             // Simuliere Ruhe (keine Bewegung, aber wir behalten animate loop laufen)
  // Questtext ersetzen
  const qb = document.getElementById('questBox');
  if(qb){
    qb.textContent = 'Heli wird betankt...';
  }
  flashMessage('Betankung gestartet');
}

function processRefuel(dt){
  if(!refueling) return;
  // Erh√∂he Treibstoff
  fuel += REFUEL_RATE * dt;
  if(fuel > 100) fuel = 100;
  updateFuelHUD();

  // wenn voll -> beenden
  if(fuel >= 100){
    finishRefuel();
  }
}

function finishRefuel(){
  if(!refueling) return;
  refueling = false;
  controlsDisabled = false; // Steuerung wieder erlauben
  outOfFuel = false;        // Motor wieder bereit (falls outOfFuel gesetzt war)
  updateFuelHUD();

  const qb = document.getElementById('questBox');
  if(qb){
    qb.textContent = 'Heli voll getankt. Du kannst wieder los fliegen.';
    // nach 2s den vorherigen Questtext wiederherstellen (falls vorhanden)
    setTimeout(()=>{
      if(refuelSavedQuestText){
        qb.textContent = refuelSavedQuestText;
        refuelSavedQuestText = null;
      }
    }, 2000);
  }
  flashMessage('Betankung abgeschlossen');
}

// --- Emergency / Game Over wegen leerem Treibstoff (angepasst) ---
// Sorge daf√ºr, dass die Flags existieren
if (typeof gameOver === 'undefined') window.gameOver = false;
if (typeof _zoomEmergencyInterval === 'undefined') window._zoomEmergencyInterval = null;
if (typeof fuelEmptyPending === 'undefined') window.fuelEmptyPending = false;

/**
 * Zoomt sukzessive auf die Notlandung-Position und ruft am Ende finalizeGameOver().
 * Nutzt vorhandene Variablen: carPos (L.LatLng), currentQuest, map, ZOOM_LAND.
 */
function handleFuelEmptyEmergency(msg){
  if (window.gameOver || window._zoomEmergencyInterval) return;

  // Bestimme Zielposition: bevorzugt derzeitige Heli-Position (carPos), sonst Quest-Location, sonst STARTPOS fallback
  let target = null;
  try {
    if (carPos && typeof carPos.lat === 'number' && typeof carPos.lng === 'number') {
      target = [carPos.lat, carPos.lng];
    } else if (currentQuest && Array.isArray(currentQuest.location) && currentQuest.location.length >= 2) {
      target = currentQuest.location;
    } else if (typeof STARTPOS !== 'undefined' && Array.isArray(STARTPOS)) {
      target = STARTPOS;
    }
  } catch (e) {
    console.warn('handleFuelEmptyEmergency: Fehler beim Bestimmen der Zielposition', e);
    target = null;
  }

  if (!target) {
    console.warn('handleFuelEmptyEmergency: keine Position vorhanden, GameOver direkt.');
    finalizeGameOver(msg);
    return;
  }

  // sichere Markierung, dass wir in die Notlandung gehen
  window.fuelEmptyPending = true;

  // sukzessive Zoom-Schritte (schrittweises Heranzoomen)
  const stepMs = 900;
  const zoomStep = 1;
  window._zoomEmergencyInterval = setInterval(() => {
    try {
      const curZoom = (map && typeof map.getZoom === 'function') ? map.getZoom() : (typeof ZOOM_LAND !== 'undefined' ? ZOOM_LAND : 19);
      // Wir wollen auf mindestens ZOOM_LAND heranzoomen (ZOOM_LAND existiert in deinem Code)
      const nextZoom = Math.min(typeof ZOOM_LAND !== 'undefined' ? ZOOM_LAND : 19, Math.round(curZoom) + zoomStep);

      if (map && typeof map.flyTo === 'function') {
        map.flyTo(target, nextZoom, { animate: true, duration: 0.8, easeLinearity: 0.25 });
      } else if (map && typeof map.panTo === 'function') {
        map.panTo(target);
        if (typeof map.setZoom === 'function') map.setZoom(nextZoom);
      }

      // Wenn wir nun auf Landezoom sind -> Spiel beenden / Notlandung ausl√∂sen
      if (Math.round(nextZoom) >= (typeof ZOOM_LAND !== 'undefined' ? ZOOM_LAND : 19)) {
        clearInterval(window._zoomEmergencyInterval);
        window._zoomEmergencyInterval = null;
        finalizeGameOver();
      }
    } catch (err) {
      console.error('Zoom-Fehler in handleFuelEmptyEmergency:', err);
      if (window._zoomEmergencyInterval) { clearInterval(window._zoomEmergencyInterval); window._zoomEmergencyInterval = null; }
      finalizeGameOver();
    }
  }, stepMs);
}


/**
 * Finale Notlandung / Game Over Anzeige.
 * Verwendet vorhandene Flags: gameOver, paused, controlsDisabled, outOfFuel.
 * F√ºgt ein Overlay mit Neustart-Button hinzu; ruft resetGame() wenn vorhanden, sonst location.reload().
 */
function finalizeGameOver(msg){
  if (window.gameOver) return;
  if (window._zoomEmergencyInterval) { clearInterval(window._zoomEmergencyInterval); window._zoomEmergencyInterval = null; }

  window.gameOver = true;
  // friere Spiel-Logik ein
  paused = true;
  // Sperre Eingaben ‚Äî in deinem Code hei√üt das controlsDisabled
  if (typeof controlsDisabled !== 'undefined') controlsDisabled = true;
  // falls outOfFuel noch nicht gesetzt ist, markiere es
  if (typeof outOfFuel !== 'undefined') outOfFuel = true;
  // clear refuel attempt
  if (typeof refueling !== 'undefined') refueling = false;
  // markiere Flag zur√ºck
  window.fuelEmptyPending = false;

  // Overlay erstellen oder wiederverwenden
  let overlay = document.getElementById('gameOverOverlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'gameOverOverlay';
    Object.assign(overlay.style, {
      position: 'fixed',
      left: '0',
      top: '0',
      right: '0',
      bottom: '0',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      background: 'rgba(0,0,0,0.75)',
      zIndex: 99999,
      color: '#fff',
      fontSize: '18px',
      padding: '20px',
      textAlign: 'center',
      flexDirection: 'column',
      gap: '16px'
    });
    document.body.appendChild(overlay);
  }

  // Inhalt mit Restart-Button (falls resetGame() vorhanden, wird diese Funktion verwendet)
  const restartHint = (typeof resetGame === 'function') ? 'Spiel zur√ºcksetzen' : 'Spiel neustarten';
  overlay.innerHTML = `
    <div style="max-width:900px;">
      <strong style="font-size:28px;display:block;margin-bottom:6px">GAME OVER</strong>
      <div>${msg}</div>
      <div style="margin-top:8px;font-weight:700">Dr√ºcke LEERTASTE zum Neustart.</div>
    </div>
  `;
  
  
  // Restart-Verhalten zentral kapseln
  function doRestart() {
    // cleanup erstmal
    cleanupOverlayListeners();

    // wenn resetGame() existiert, nutze es; sonst reload
    if (typeof resetGame === 'function') {
      try { overlay.remove(); } catch (e) {}
      resetGame();
    } else {
      location.reload();
    }
  }

  // Cleanup-Funktion: entfernt Listener + Overlay DOM
  function cleanupOverlayListeners() {
    // Entferne globalen Key-Handler
    document.removeEventListener('keydown', onGameOverKeyDown);
    // Entferne Overlay aus DOM
    try { const o = document.getElementById('gameOverOverlay'); if (o) o.remove(); } catch(e){}
  }

  // Keydown-Handler (named, damit wir ihn wieder entfernen k√∂nnen)
  function onGameOverKeyDown(e) {
    // Enter = Neustart
    if (e.key === ' ') {
      e.preventDefault();
      doRestart();
      return;
    }
    // optional: Escape schlie√üt das Overlay (ohne Neustart)
    if (e.key === 'Escape') {
      e.preventDefault();
      cleanupOverlayListeners();
      return;
    }
  }

  // Buttons hooken (falls noch nicht gemacht)
  const restartBtn = document.getElementById('restartBtn');
  if (restartBtn) {
    restartBtn.onclick = (ev) => { ev.preventDefault(); doRestart(); };
  }

  const dbgClose = document.getElementById('dbgCloseGame');
  if (dbgClose) {
    dbgClose.onclick = (ev) => { ev.preventDefault(); cleanupOverlayListeners(); };
  }

  // registriere den Key-Handler (sofern nicht bereits registriert)
  document.addEventListener('keydown', onGameOverKeyDown);

  // optionale Console-Meldung
  //console.log('finalizeGameOver: Game over gesetzt.');
}




// load quests
loadQuests('quests.json');

// ---------------- ANIMATE (neu: Wind, boost, headwind penalty, ground vel) ----------------
let last = null;
function animate(ts){

const dt = Math.min(0.05, (ts - last)/1000);

   if(refueling){
    processRefuel(Math.min(dt, 0.2)); // dt in Sekunden
    // wir wollen w√§hrend Betankung nicht weiter an Bewegung / Steuerung arbeiten
    // aber HUD / map updates etc. k√∂nnen bleiben
    document.getElementById('speed').textContent = (speed).toFixed(1);
    updateNavigationUI();
    requestAnimationFrame(animate);
    return;
  }

  if(paused){ last = ts; requestAnimationFrame(animate); return; }
  if(!last) last = ts;
  
  

 
  
  last = ts;

  // if landed: disable movement but still update HUD/navigation
  if(!isLanded()){
    // steering
    const steerSpeed = 140;
    if(keys.ArrowLeft) headingDeg = (headingDeg - steerSpeed * dt + 360) % 360;
    if(keys.ArrowRight) headingDeg = (headingDeg + steerSpeed * dt) % 360;

    // --- Wind now (incl gust) ---
    const now = performance.now() / 1000;
    const gust = wind.gustAmp ? (wind.gustAmp * Math.sin(now * wind.gustFreq * Math.PI * 2 + wind.seed)) : 0;
    const windSpeedNow = wind.speed + gust;
    const windRad = toRad(wind.dir || 0);
    const wind_v_n = windSpeedNow * Math.cos(windRad);
    const wind_v_e = windSpeedNow * Math.sin(windRad);
	
	const helRad = toRad(headingDeg);

	// Windkomponente entlang der Flugrichtung (positiv = Tailwind)
	const windAlongHeading = wind_v_n * Math.cos(helRad) + wind_v_e * Math.sin(helRad);

	// Kopfwind-Magnitude (positiv wenn Gegenwind)
	const headwind = Math.max(0, -windAlongHeading);

	// penalty: 1.0 = keine Einschr√§nkung, minimaler Faktor z.B. 0.4
	const HEADWIND_SCALE = 30; // anpassbar
	const MIN_PENALTY = 0.4;
	const headwindPenaltyFactor = (headwind > 0) ? Math.max(MIN_PENALTY, 1 - headwind / HEADWIND_SCALE) : 1.0;


    // --- preset / boost decision (boost disabled if wind too strong) ---
    const preset = (typeof GEARS[currentGear] === 'number') ? GEARS[currentGear] : (MAX_SPEED || 0);
    let allowBoost = false;
    if(currentQuest){
      const target = (questState === 'toScene') ? currentQuest.location : (currentQuest.hospital && currentQuest.hospital.location);
      if(target){
        const distToTarget = distanceMetersBetween(heliPos, target);
        allowBoost = distToTarget > 200;
      }
    }
    if(windSpeedNow > BOOST_WIND_LIMIT) allowBoost = false;
    const boostFactor = (boostActive && allowBoost) ? BOOST_MULT : 1.0;
    const effectiveMax = preset * boostFactor;

    // throttle input
    let throttleInput = 0;
    if (keys.ArrowUp) throttleInput = 1;
    else if (keys.ArrowDown) throttleInput = -0.5;
	
	// wenn leerer Tank: keine Beschleunigung / kein Boost erlauben
    if(outOfFuel){
      // verbiete Schub und Boost, aber lasse das Heli nat√ºrlich ausrollen
      throttleInput = 0;
      boostActive = false;
	  
	  if (fuel <= 0 && !window.fuelEmptyPending) {
	  outOfFuel = true;
	  handleFuelEmptyEmergency('Treibstoff leer. Tanke das n√§chste mal rechtzeitig; fliege daf√ºr einfach den Hangar an, wo du gestartet bist, und lande dort. Der Heli wird dann betankt.');
}
	  
      // evtl. langsamer Stop statt sofortiger Nullsetzung:
      // (hier wird Bremskraft im restlichen Loop weiter angewandt)
    } else {
      // ansonsten Treibstoff verbrauchen (nur wenn nicht gelandet)
      if(!isLanded()){
        // consumeFuel erwartet dt in Sekunden
        consumeFuel(dt, throttleInput, speed, (boostActive && allowBoost));
      }
    }

    // agility for quick response just after gear change
    let agility = 1.0;
    if(lastGearChangeTime){
      const since = (performance.now() - lastGearChangeTime) / 1000;
      if(since < 0.25) agility = 1.6;
    }

    // desired airspeed
    const desired = effectiveMax * throttleInput;

    // acceleration limited approach (prevent jump when shifting gear)
    const delta = desired - speed;
    const accelBase = (boostActive && allowBoost) ? (ACCEL * BOOST_ACCEL_MULT) : ACCEL;
	const accelCap = accelBase * headwindPenaltyFactor * agility * dt;
    let dv = 0;
    if(delta > 0){
      dv = Math.min(delta, accelCap);
    } else if(delta < 0){
      dv = Math.max(delta, -BRAKE_DECEL * dt);
    }
    speed += dv;

    // passive drag + friction applied to airspeed
	// passive drag + friction applied to airspeed
	// deutlich kleinere Drag-Konstante, sonst √ºbersteigt quadratic drag den Antrieb bei hohen Geschw.
	const DRAG_COEFF = 1e-5; // vorher 0.0008 ‚Äî zu gro√ü f√ºr v^2-Term
	if(Math.abs(speed) > 0.0001){
	  const dragDecel = DRAG_COEFF * speed * Math.abs(speed);
	  const linearDecel = FRICTION;
	  const totalDecel = (dragDecel + linearDecel) * dt;
	  if(speed > 0) speed = (speed - totalDecel > 0) ? speed - totalDecel : 0;
	  else speed = (speed + totalDecel < 0) ? speed + totalDecel : 0;
	}

    if(keys.ArrowDown && speed > 0){
      speed = Math.max(0, speed - (BRAKE_DECEL * 0.5) * dt);
    }

    // soft clamps
    const lowerBound = -effectiveMax * 0.5;
    if(speed > effectiveMax) speed = Math.max(effectiveMax, speed - BRAKE_DECEL * dt);
    if(speed < lowerBound) speed = Math.min(lowerBound, speed + BRAKE_DECEL * dt);

    // compute ground velocity (air + wind)
    const ground_v_n = speed * Math.cos(helRad) + wind_v_n;
    const ground_v_e = speed * Math.sin(helRad) + wind_v_e;
    const ground_speed = Math.sqrt(ground_v_n*ground_v_n + ground_v_e*ground_v_e);

    if(ground_speed > 0.0001){
      const move = ground_speed * dt;
      const moveBearingDeg = (toDeg(Math.atan2(ground_v_e, ground_v_n)) + 360) % 360;
      heliPos = destinationPoint(heliPos.lat, heliPos.lng, move, moveBearingDeg);

      if(!autoPanSuspended){
        map.panTo(heliPos, {animate:false});
      } else {
        pendingAutoPan = true;
      }
    }
  } else {
    // landed
    speed = 0;
  }

  // HUD: show preset and boost availability
  const presetNow = (typeof GEARS[currentGear] === 'number') ? GEARS[currentGear] : (MAX_SPEED || 0);
  const canBoostNow = boostActive && currentQuest && distanceMetersBetween(heliPos, ((questState === 'toScene')? currentQuest.location : currentQuest.hospital.location)) > 200 && getCurrentWindSpeed() <= BOOST_WIND_LIMIT;
  document.getElementById('maxSpeed').textContent = Math.round(presetNow * (canBoostNow ? BOOST_MULT : 1));

  // display speed, UI and checks
  document.getElementById('speed').textContent = (speed).toFixed(1);
  updateZoomUI();
  const heliDiv = document.getElementById('heliDiv');
  if(heliDiv){ heliDiv.style.transform = `translate(-50%,-50%) rotate(${(headingDeg)}deg)`; }

  // quest & nav
  checkQuestProgress();
  updateNavigationUI();

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);

// resize inval
window.addEventListener('resize', ()=>{ setTimeout(()=>map.invalidateSize(),120); });

// init HUD
map.whenReady(()=>{
  updateZoomUI();
  document.getElementById('maxSpeed').textContent = Math.round(MAX_SPEED);
});

// --- Fuel HUD (Top-Right) ---
(function createFuelHUD(){
  const el = document.createElement('div');
  el.id = 'fuelHUD';
  Object.assign(el.style, {
    position: 'fixed',
    right: '12px',
    top: '12px',
    zIndex: 16000,
    width: '200px',
    background: 'rgba(255,255,255,0.95)',
    padding: '8px 10px',
    borderRadius: '10px',
    boxShadow: '0 8px 24px rgba(0,0,0,0.12)',
    //fontWeight: '800',
    //fontFamily: "ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, Arial",
    //fontSize: '13px'
  });
  el.classList.add('konsolentext');
  el.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
      <div class="konsolentext">Treibstoff</div>
      <div id="fuelPercentTxt" class="konsolentext">${Math.ceil(fuelPercent)}%</div>
    </div>
    <div style="height:10px;background:#eee;border-radius:8px;overflow:hidden">
      <div id="fuelBar" style="height:100%;width:100%;background:green;transform-origin:left;transform:scaleX(1)"></div>
    </div>
  `;
  document.body.appendChild(el);
})();
</script>

<script>
function applyFilterFromJson(jsonObj) {
	if (!jsonObj || !jsonObj.state) return;
	for (const [variable, cfg] of Object.entries(jsonObj.state)) {
	if (!variable || !cfg) continue;
	let value = cfg.value || '';
	if (cfg.suffix) {
	value += cfg.suffix;
	}
	document.documentElement.style.setProperty(variable, value);
	}
}
/*

CHEATS
	Open the Console by pressing ~ on the keyboard.

	fillmeup: refills the fuel
	itsnooveryet: continue the game, if game over
	nostress: disables quests
	imthewinner: congratulations, you've won all the quests.
	imtherocketman: you can fly as high as you like. The higher you fly, the faster you go.
	
	// Colors
	
	nightmap: the map is colored in nightvision
	oldmap: the map is colored like an old map
	wintermap: icy winter colors
	wearefogged: foggy map
	resetcolors:  resets the colors of the map

*/

(function(){
  const consoleEl = document.getElementById('cheat-console');
  const inputEl = document.getElementById('console-input');
  const logEl = document.getElementById('console-log');

  const cheats = {
  'fillmeup': () => {
    fuel = 100;          // Tank sofort voll
    outOfFuel = false;   // sicherstellen, dass Motor wieder l√§uft
    updateFuelHUD();     // HUD-Update triggern
    alert('Tank wieder voll! üöÅ‚õΩ');
  },
  'itsnotoveryet': () => {
    // Tank auff√ºllen
    fuel = 100;
    outOfFuel = false;
    updateFuelHUD();

    // GameOver r√ºckg√§ngig machen
    window.gameOver = false;
    paused = false;
    controlsDisabled = false;

    // Overlay entfernen (falls sichtbar)
    const overlay = document.getElementById('gameOverOverlay');
    if (overlay) overlay.remove();

    alert('Weiter geht‚Äôs ‚Äì Tank voll, Game Over r√ºckg√§ngig!');
  },
  
  // in deine cheats-Map einf√ºgen
'nostress': () => {
  try {
    // cancel any scheduled next-quest
    if (window._nextQuestTimeout) { clearTimeout(window._nextQuestTimeout); window._nextQuestTimeout = null; }
    window._suppressNextQuest = true;

    // stop any game-over zoom/interval
    if (window._zoomEmergencyInterval) { clearInterval(window._zoomEmergencyInterval); window._zoomEmergencyInterval = null; }

    // stop and remove visual pulses/overlays for quests
    try { if (activeScenePulse) { activeScenePulse.stop(); activeScenePulse = null; } } catch(e){}
    try { if (activeHospitalPulse) { activeHospitalPulse.stop(); activeHospitalPulse = null; } } catch(e){}

    // clear quest data -> keine Quests mehr
    quests = [];
    currentQuestIndex = -1;
    currentQuest = null;
    questState = null;

    // update UI
    updateCompletedBox(0, 0);
    const qb = document.getElementById('questBox');
    if (qb) qb.textContent = 'Keine Quests (Cheat aktiviert)';
    showNavUI(false);
	qb.style.display = "none";
	document.getElementById("questContainer").style.display="none";

    // feedback
    if (typeof flashMessage === 'function') flashMessage('Cheat: Keine Quests mehr ‚Äî enjoy! üéâ');
    else alert('Cheat: Keine Quests mehr ‚Äî enjoy! üéâ');
  } catch (err) {
    console.error('nostress cheat failed', err);
    alert('Fehler beim Anwenden von "nostress": ' + (err && err.message ? err.message : err));
  }
},

'imthewinner': () => {
  try {
    // cancel any scheduled next-quest
    if (window._nextQuestTimeout) { clearTimeout(window._nextQuestTimeout); window._nextQuestTimeout = null; }
    window._suppressNextQuest = true;

    // stop any game-over zoom/interval
    if (window._zoomEmergencyInterval) { clearInterval(window._zoomEmergencyInterval); window._zoomEmergencyInterval = null; }

    // stop and remove visual pulses/overlays for current quest
    try { if (activeScenePulse) { activeScenePulse.stop(); activeScenePulse = null; } } catch(e){}
    try { if (activeHospitalPulse) { activeHospitalPulse.stop(); activeHospitalPulse = null; } } catch(e){}

    // mark all quests as completed (keine neue Quest starten)
    const total = Array.isArray(quests) ? quests.length : 0;
    currentQuest = null;
    questState = null;
    currentQuestIndex = total; // indicates all done

    // update UI: Completed x of x
    updateCompletedBox(total, total);
    const qb = document.getElementById('questBox');
    if (qb) qb.textContent = 'Alle Eins√§tze erledigt ‚Äî Gl√ºckwunsch!';

    // hide nav and school other quest visuals
    showNavUI(false);

    // feedback
    if (typeof flashMessage === 'function') flashMessage('Alle Quests als erledigt markiert ‚úÖ');
    else alert('Alle Quests als erledigt markiert ‚úÖ');
  } catch (err) {
    console.error('imthewinner cheat failed', err);
    alert('Fehler beim Anwenden von "imthewinner": ' + (err && err.message ? err.message : err));
  }
},

// Extrem aggressive Rocket-Mode (sehr starke Beschleunigungs- & Brems-Skalierung)
'imtherocketman': () => {
  try {
    if (typeof map === 'undefined' || typeof GEARS === 'undefined') {
      alert('Rocketmode nicht verf√ºgbar (map/GEARS fehlen).');
      return;
    }

    // Toggle: wenn aktiv -> restore
    if (window._rocketModeActive) {
	
	boostActive = false;
    window._disableBoost = false;   // Sperre wieder aufheben

		
	if (window._FUEL_CONFIG_ORIG && typeof FUEL_CONFIG !== 'undefined') {
	  try {
		FUEL_CONFIG.base     = window._FUEL_CONFIG_ORIG.base;
		FUEL_CONFIG.throttle = window._FUEL_CONFIG_ORIG.throttle;
		FUEL_CONFIG.speed    = window._FUEL_CONFIG_ORIG.speed;
		FUEL_CONFIG.boost    = window._FUEL_CONFIG_ORIG.boost;
	  } catch(e) {
		console.warn('Rocket-mode: Fehler beim Wiederherstellen des FUEL_CONFIG', e);
	  }
	  window._FUEL_CONFIG_ORIG = null;
	}

	// optional: RANGE_KM override entfernen, falls gesetzt
	if (typeof window._RANGE_KM_OVERRIDE !== 'undefined') {
	  window._RANGE_KM_OVERRIDE = undefined;
	}

	
      if (window._rocketInterval) { clearInterval(window._rocketInterval); window._rocketInterval = null; }

      if (window._GEARS_ORIG) {
        Object.keys(window._GEARS_ORIG).forEach(k => { GEARS[k] = window._GEARS_ORIG[k]; });
        window._GEARS_ORIG = null;
      }

      if (typeof window._ACCEL_ORIG !== 'undefined') { ACCEL = window._ACCEL_ORIG; window._ACCEL_ORIG = undefined; }
      if (typeof window._BRAKE_DECEL_ORIG !== 'undefined') { BRAKE_DECEL = window._BRAKE_DECEL_ORIG; window._BRAKE_DECEL_ORIG = undefined; }
      if (typeof window._BOOST_ACCEL_MULT_ORIG !== 'undefined') { BOOST_ACCEL_MULT = window._BOOST_ACCEL_MULT_ORIG; window._BOOST_ACCEL_MULT_ORIG = undefined; }

      if (typeof window._ZOOM_MIN_ORIG !== 'undefined') {
        try { ZOOM_MIN = window._ZOOM_MIN_ORIG; } catch(e){}
        try { if (typeof map.setMinZoom === 'function') map.setMinZoom(window._MAP_MINZOOM_ORIG); } catch(e){}
        window._ZOOM_MIN_ORIG = undefined;
        window._MAP_MINZOOM_ORIG = undefined;
      }

      window._rocketModeActive = false;
      if (typeof flashMessage === 'function') flashMessage('Rocket-Mode deaktiviert ‚Äî Werte wiederhergestellt');
      else alert('Rocket-Mode deaktiviert ‚Äî Werte wiederhergestellt');
      return;
    }

    // === Aktivieren: Originalwerte sichern ===
    window._rocketModeActive = true;
	window._disableBoost = true;      // Boost sperren
    window._GEARS_ORIG = Object.assign({}, GEARS);
    window._ACCEL_ORIG = (typeof ACCEL !== 'undefined') ? ACCEL : null;
    window._BRAKE_DECEL_ORIG = (typeof BRAKE_DECEL !== 'undefined') ? BRAKE_DECEL : null;
    window._BOOST_ACCEL_MULT_ORIG = (typeof BOOST_ACCEL_MULT !== 'undefined') ? BOOST_ACCEL_MULT : null;
    window._ZOOM_MIN_ORIG = (typeof ZOOM_MIN !== 'undefined') ? ZOOM_MIN : null;
    window._MAP_MINZOOM_ORIG = map.options && typeof map.options.minZoom !== 'undefined' ? map.options.minZoom : null;
	
	alert("üöÄ I'm the rocketman!");
	
    // Erlaube extremes Hinauszoomen
    try { ZOOM_MIN = 0; } catch(e){ /* falls noch const */ }
    try { if (typeof map.setMinZoom === 'function') map.setMinZoom(0); } catch(e){}

    // ---------- EXTREM-TUNING (du wolltest "viel viel viel st√§rker") ----------
    // factorPerLevel: Basiswachstum pro Zoom-Level (gr√∂√üer = schneller)
    const factorPerLevel = 2.0;   // sehr stark (3x pro Level)
    // Exponenten: wie stark ACCEL/BRAKE skaliert werden relativ zur Speed-Multiplikation
    const accelExponent = 5.0;    // Beschleunigung ~ mult^5  (extrem)
    const brakeExponent = 10.0;   // Bremsen ~ mult^10    (noch extremer, damit stoppbar)
    const boostAccelExponent = 1.0; // Boost-Multiplikator moderat skalieren

    // Caps: verhindert numerische √úberl√§ufe / v√∂llig unspielbare Werte.
    // Du kannst diese sehr gro√üz√ºgig erh√∂hen/senken.
    const MAX_ACCEL_MULT = 1e8;   // maximaler Faktor gegen√ºber original ACCEL
    const MAX_BRAKE_MULT = 1e12;  // maximaler Faktor gegen√ºber original BRAKE_DECEL
    const MAX_GEAR_MULT = 1e6;    // maximaler Faktor f√ºr GEARS

    const originalMinZoom = (typeof window._ZOOM_MIN_ORIG === 'number') ? window._ZOOM_MIN_ORIG : 15;

// innerhalb von 'imtherocketman' ‚Äî vor dem Start des rocketInterval (oder in der Aktivierungs-Phase)
try {
  // --- Treibstoff: sehr langsamer Verbrauch (einfacher "gro√üer Tank") ---
  if (typeof FUEL_CONFIG !== 'undefined') {
    // sichere Originalwerte (deep copy der Zahlen)
    window._FUEL_CONFIG_ORIG = {
      base: typeof FUEL_CONFIG.base === 'number' ? FUEL_CONFIG.base : 0.1,
      throttle: typeof FUEL_CONFIG.throttle === 'number' ? FUEL_CONFIG.throttle : 0.18,
      speed: typeof FUEL_CONFIG.speed === 'number' ? FUEL_CONFIG.speed : 0.002,
      boost: typeof FUEL_CONFIG.boost === 'number' ? FUEL_CONFIG.boost : 0.0
    };

    // extrem kleinen Verbrauch setzen (je kleiner = l√§nger h√§lt der Tank)
    // Feinjustierbar: z.B. 1e-4 bis 1e-7 ‚Äî je kleiner, desto l√§nger
    const consumptionScale = 1e-6; // << sehr, sehr langsam verbrauchend

    FUEL_CONFIG.base     = window._FUEL_CONFIG_ORIG.base     * consumptionScale;
    FUEL_CONFIG.throttle = window._FUEL_CONFIG_ORIG.throttle * consumptionScale;
    FUEL_CONFIG.speed    = window._FUEL_CONFIG_ORIG.speed    * consumptionScale;
    FUEL_CONFIG.boost    = window._FUEL_CONFIG_ORIG.boost    * consumptionScale;
  }

  // Falls du die "Reichweite" im HUD deutlich gr√∂√üer erscheinen lassen willst (optional),
  // kannst du hier zus√§tzlich ein Override-Flag setzen, das updateFuelHUD nutzt (falls du die HUD-Funktion anpasst).
  // window._RANGE_KM_OVERRIDE = (typeof RANGE_KM === 'number') ? RANGE_KM * 1000 : 50000;

  // F√ºlle den Tank sofort auf 100% (so startest du mit vollem ‚ÄûMega-Tank‚Äú)
  if (typeof fuel !== 'undefined') {
    fuel = 100;
    outOfFuel = false;
    if (typeof updateFuelHUD === 'function') updateFuelHUD();
  }
} catch (e) {
  console.warn('Rocket-mode: Fehler beim Anpassen des Treibstoffs', e);
}


    // Interval: passt GEARS, ACCEL, BRAKE_DECEL, BOOST_ACCEL_MULT an
    window._rocketInterval = setInterval(() => {
      try {
        const curZoom = (typeof map.getZoom === 'function') ? map.getZoom() : originalMinZoom;
        const levelsOut = Math.max(0, Math.round(originalMinZoom - curZoom));

        // extrem schneller Wachstumsfaktor
        const mult = Math.pow(factorPerLevel, levelsOut);

        // --- GEARS: maxspeed pro Gang (gerundet), mit Cap ---
        Object.keys(window._GEARS_ORIG).forEach(k => {
          const val = window._GEARS_ORIG[k];
          if (typeof val === 'number') {
            const scaled = val * Math.min(Math.pow(mult, 1), MAX_GEAR_MULT); // gear linear zu mult, capped
            GEARS[k] = Math.max(1, Math.round(scaled));
          }
        });

        // --- ACCEL: VIEL st√§rker (exponentiell) ---
        if (typeof window._ACCEL_ORIG === 'number') {
          const accelScale = Math.pow(mult, accelExponent);
          const accelScaleCapped = Math.min(accelScale, MAX_ACCEL_MULT);
          ACCEL = window._ACCEL_ORIG * accelScaleCapped;
        }

        // --- BRAKE_DECEL: NOCH viel st√§rker (exponentiell) ---
        if (typeof window._BRAKE_DECEL_ORIG === 'number') {
          const brakeScale = Math.pow(mult, brakeExponent);
          const brakeScaleCapped = Math.min(brakeScale, MAX_BRAKE_MULT);
          BRAKE_DECEL = window._BRAKE_DECEL_ORIG * brakeScaleCapped;
        }

        // --- BOOST_ACCEL_MULT: moderat skalieren, aber cappen ---
        if (typeof window._BOOST_ACCEL_MULT_ORIG === 'number') {
          const bScale = Math.pow(mult, boostAccelExponent);
          BOOST_ACCEL_MULT = Math.min(window._BOOST_ACCEL_MULT_ORIG * bScale, 1e6);
        }

        // optional: update sichtbares MaxSpeed im HUD (schnellere Darstellung)
        try { document.getElementById('maxSpeed').textContent = Math.round(GEARS[currentGear] || 0); } catch(e){}

      } catch (err) {
        // ignore transient errors
        console.debug('rocket tick error', err);
      }
    }, 60); // schneller Tick f√ºr reaktive Anpassung

    if (typeof flashMessage === 'function') flashMessage('ROCKET MODE: ON ‚Äî extreme Beschleunigung & SUPER-Bremsen!');
    else alert('ROCKET MODE: ON ‚Äî extreme Beschleunigung & SUPER-Bremsen!');

  } catch (err) {
    console.error('imtherocketman error', err);
    alert('Fehler beim Aktivieren von Rocket-Mode: ' + (err && err.message ? err.message : err));
  }
},


// Farben 

'nightmap': () => {
  try {
	const presetJson = {
		"created": "2025-09-25T19:34:29.048Z",
		"state": {
		"--map-hue": { "value": "314", "suffix": "deg", "type": "range" },
		"--map-sat": { "value": "1.5", "suffix": "", "type": "range" },
		"--map-contrast": { "value": "0.8", "suffix": "", "type": "range" },
		"--map-bright": { "value": "1.1", "suffix": "", "type": "range" },
		"--map-invert": { "value": "1", "suffix": "", "type": "range" },
		"--map-sepia": { "value": "0", "suffix": "", "type": "range" },
		"--map-gray": { "value": "0", "suffix": "", "type": "range" },
		"--map-blur": { "value": "0", "suffix": "px", "type": "range" },
		"--map-shadow-x": { "value": "0", "suffix": "px", "type": "range" },
		"--map-shadow-y": { "value": "0", "suffix": "px", "type": "range" },
		"--map-shadow-blur": { "value": "0", "suffix": "px", "type": "range" },
		"--map-shadow-color": { "value": "#416fb4", "suffix": "", "type": "color" },
		"undefined": { "value": "", "suffix": "", "type": "file" }
		}
	};

	applyFilterFromJson(presetJson);
	
	} catch (err) {
		console.error('night error', err);
		alert('Fehler beim Aktivieren von Night-Mode: ' + (err && err.message ? err.message : err));
	}
},

'oldmap': () => {
  try {
	const presetJson = {
  "created": "2025-09-25T19:14:41.766Z",
  "state": {
    "--map-hue": {
      "value": "45",
      "suffix": "deg",
      "type": "range"
    },
    "--map-sat": {
      "value": "4",
      "suffix": "",
      "type": "range"
    },
    "--map-contrast": {
      "value": "0.8",
      "suffix": "",
      "type": "range"
    },
    "--map-bright": {
      "value": "0.7",
      "suffix": "",
      "type": "range"
    },
    "--map-invert": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-sepia": {
      "value": "1",
      "suffix": "",
      "type": "range"
    },
    "--map-gray": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-blur": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-x": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-y": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-blur": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-color": {
      "value": "#000000",
      "suffix": "",
      "type": "color"
    },
    "undefined": {
      "value": "",
      "suffix": "",
      "type": "file"
    }
  }
};

	applyFilterFromJson(presetJson);
	
	} catch (err) {
		console.error('night error', err);
		alert('Fehler beim Aktivieren von Night-Mode: ' + (err && err.message ? err.message : err));
	}
},

'wintermap': () => {
  try {
	const presetJson = {
  "created": "2025-09-25T20:26:18.956Z",
  "state": {
    "--map-hue": {
      "value": "128",
      "suffix": "deg",
      "type": "range"
    },
    "--map-sat": {
      "value": "0.9",
      "suffix": "",
      "type": "range"
    },
    "--map-contrast": {
      "value": "1",
      "suffix": "",
      "type": "range"
    },
    "--map-bright": {
      "value": "1",
      "suffix": "",
      "type": "range"
    },
    "--map-invert": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-sepia": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-gray": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-blur": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-x": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-y": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-blur": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-color": {
      "value": "#000000",
      "suffix": "",
      "type": "color"
    },
    "undefined": {
      "value": "",
      "suffix": "",
      "type": "file"
    }
  }
};

	applyFilterFromJson(presetJson);
	
	} catch (err) {
		console.error('night error', err);
		alert('Fehler beim Aktivieren von Night-Mode: ' + (err && err.message ? err.message : err));
	}
},

'wearefogged': () => {
  try {
	const presetJson = {
  "created": "2025-09-25T20:45:46.630Z",
  "state": {
    "--map-hue": {
      "value": "0",
      "suffix": "deg",
      "type": "range"
    },
    "--map-sat": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-contrast": {
      "value": "0.1",
      "suffix": "",
      "type": "range"
    },
    "--map-bright": {
      "value": "1.1",
      "suffix": "",
      "type": "range"
    },
    "--map-invert": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-sepia": {
      "value": "0.1",
      "suffix": "",
      "type": "range"
    },
    "--map-gray": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-blur": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-x": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-y": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-blur": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-color": {
      "value": "#000000",
      "suffix": "",
      "type": "color"
    },
    "undefined": {
      "value": "",
      "suffix": "",
      "type": "file"
    }
  }
};

	applyFilterFromJson(presetJson);
	
	} catch (err) {
		console.error('night error', err);
		alert('Fehler beim Aktivieren von Night-Mode: ' + (err && err.message ? err.message : err));
	}
},

'resetcolors': () => {
  try {
	const presetJson = {
  "created": "2025-09-25T19:58:57.202Z",
  "state": {
    "--map-hue": {
      "value": "0",
      "suffix": "deg",
      "type": "range"
    },
    "--map-sat": {
      "value": "1",
      "suffix": "",
      "type": "range"
    },
    "--map-contrast": {
      "value": "1",
      "suffix": "",
      "type": "range"
    },
    "--map-bright": {
      "value": "1",
      "suffix": "",
      "type": "range"
    },
    "--map-invert": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-sepia": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-gray": {
      "value": "0",
      "suffix": "",
      "type": "range"
    },
    "--map-blur": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-x": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-y": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-blur": {
      "value": "0",
      "suffix": "px",
      "type": "range"
    },
    "--map-shadow-color": {
      "value": "#000000",
      "suffix": "",
      "type": "color"
    },
    "undefined": {
      "value": "",
      "suffix": "",
      "type": "file"
    }
  }
};

	applyFilterFromJson(presetJson);
	
	} catch (err) {
		console.error('night error', err);
		alert('Fehler beim Aktivieren von Night-Mode: ' + (err && err.message ? err.message : err));
	}
},
  

} // end of cheats

  window.addEventListener('keydown', (e) => {
    const active = document.activeElement;
    const isForm = active && (active.tagName==='INPUT' || active.tagName==='TEXTAREA' || active.isContentEditable);
    if (isForm && active !== inputEl) return;

    if (e.key === '~'){ e.preventDefault(); toggleConsole(); }
    if (e.key === 'Escape' && consoleEl.style.display !== 'none'){ hideConsole(); }
  });

  function toggleConsole(){ (consoleEl.style.display==='none'||consoleEl.style.display==='') ? showConsole() : hideConsole(); }
  function showConsole(){ consoleEl.style.display='block'; inputEl.value=''; inputEl.focus(); setTimeout(()=> consoleEl.scrollTop=consoleEl.scrollHeight,0); }
  function hideConsole(){ consoleEl.style.display='none'; }

  inputEl.addEventListener('keydown', (e) => {
    if(e.key==='Enter'){ e.preventDefault();
      const raw=inputEl.value||''; const text=raw.trim();
      appendLog('> '+raw);
      if(text && cheats.hasOwnProperty(text.toLowerCase())) cheats[text.toLowerCase()]();
      else if(text) appendLog('[Unbekannter Befehl] '+text);
      inputEl.value=''; setTimeout(()=> consoleEl.scrollTop=consoleEl.scrollHeight,0);
    }
  });

  function appendLog(text){ const node=document.createElement('div'); node.textContent=text; logEl.appendChild(node); }
  hideConsole();
})();


</script>
</body>
</html>
